Configuring your React Application:
1. Configure your React Project to use Reactstrap:
   Reactstrap is a package supporting easy to use React based Bootstrap 4 components.
   To configure your project to use reactstrap, type the following at the prompt to install reactstrap, and Bootstrap 4:
   yarn add bootstrap@4.0.0
   yarn add reactstrap@5.0.0
   yarn add react-popper@0.9.2

2. Configure to use Bootstrap 4:
   Next, open index.js file in the src folder and add the following line into the imports before the import of index.css(to apply custom css on bootstrap styles):
   import 'bootstrap/dist/css/bootstrap.min.css';

3. Adding a Navigation Bar:
   Open App.js in the src folder and update it as follows:
   import { Navbar, NavbarBrand } from 'reactstrap';

class App extends Component {
  render() {
    return (
      <div className="App">
        <Navbar dark color="primary">
          <div className="container">
            <NavbarBrand href="/">Ristorante Con Fusion</NavbarBrand>
          </div>
        </Navbar>
      </div>
    );
  }
}

Exercise (Instructions): React Components Part 1:
Objectives and Outcomes
In this exercise you will add the first component to your React application and update its view using JSX. At the end of this exercise you will be able to:
1.Add components to your React application
2.Use JSX to define the views of your component.

1.Adding a Menu Component
  First, download the images.zip file provided above and then unzip the file.
  Create a folder named assets in the public folder.
  Move the resulting images folder containing some PNG files to the React project's public/assets folder.
  These image files will be useful for our exercises.

2.Next, add a new folder named components in the src folder, and create a new file named MenuComponent.js in this folder.
  Add the following code to MenuComponent.js:
  import React, { Component } from 'react';
  import { Media } from 'reactstrap';

  class Menu extends Component {
        constructor(props) {
            super(props);
            this.state = {
                dishes: [
                    {
                      id: 0,
                      name:'Uthappizza',
                      image: 'assets/images/uthappizza.png',
                      category: 'mains',
                      label:'Hot',
                      price:'4.99',
                      description:'A unique combination of Indian Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer.'                        },
                  {
                      id: 1,
                      name:'Zucchipakoda',
                      image: 'assets/images/zucchipakoda.png',
                      category: 'appetizer',
                      label:'',
                      price:'1.99',
                      description:'Deep fried Zucchini coated with mildly spiced Chickpea flour batter accompanied with a sweet-tangy tamarind sauce'                        },
                  {
                      id: 2,
                      name:'Vadonut',
                      image: 'assets/images/vadonut.png',
                      category: 'appetizer',
                      label:'New',
                      price:'1.99',
                      description:'A quintessential ConFusion experience, is it a vada or is it a donut?'                        },
                  {
                      id: 3,
                      name:'ElaiCheese Cake',
                      image: 'assets/images/elaicheesecake.png',
                      category: 'dessert',
                      label:'',
                      price:'2.99',
                      description:'A delectable, semi-sweet New York Style Cheese Cake, with Graham cracker crust and spiced with Indian cardamoms'                        }
                  ],
            };
        }

      render() {
          const menu = this.state.dishes.map((dish) => {
              return (
                <div key={dish.id} className="col-12 mt-5">
                  <Media tag="li">
                    <Media left middle>
                        <Media object src={dish.image} alt={dish.name} />
                    </Media>
                    <Media body className="ml-5">
                      <Media heading>{dish.name}</Media>
                      <p>{dish.description}</p>
                    </Media>
                  </Media>
                </div>
              );
          });

          return (
            <div className="container">
              <div className="row">
                <Media list>
                    {menu}
                </Media>
              </div>
            </div>
          );
      }
  }
  export default Menu;

3.Next, open App.js file and update it as follows:
  import Menu from './components/MenuComponent';
. . .
  <Menu />
. . .
4.Open App.css file and delete all its contents.
5.Save all changes and do a Git commit with the message "Components Part 1".

Conclusions
In this exercise we added a new component to our React application, added data to its class, and then updated the app to show the information in the web page.


Exercise React Components Part 2

Objectives and Outcomes
In this exercise we will continue modifying the menu component from the previous exercise.
Instead of a list, we will use a Card component from reactstrap to display the menu in a different way.
Also we will use the Card component to display the details of a selected dish.
At the end of this exercise you will be able to:
1.Make use of the Card component to display a list of items.
2.Use the Card component to display detailed information.

1.Updating the Menu Component
  Open MenuComponent.js and update its contents as follows.
  Note that we have removed the dishes variable from the state of the component, and updated it to use the Card:
   . . .

  import { Card, CardImg, CardImgOverlay, CardText, CardBody,
    CardTitle } from 'reactstrap';

  class Menu extends Component {

    constructor(props) {
        super(props);

        this.state = {
            selectedDish: null
        }
    }

    onDishSelect(dish) {
        this.setState({ selectedDish: dish});
    }

    renderDish(dish) {
        if (dish != null)
            return(
                <Card>
                    <CardImg top src={dish.image} alt={dish.name} />
                    <CardBody>
                      <CardTitle>{dish.name}</CardTitle>
                      <CardText>{dish.description}</CardText>
                    </CardBody>
                </Card>
            );
        else
            return(
                <div></div>
            );
    }

    render() {
        const menu = this.props.dishes.map((dish) => {
            return (
              <div  className="col-12 col-md-5 m-1">
                <Card key={dish.id}
                  onClick={() => this.onDishSelect(dish)}>
                  <CardImg width="100%" src={dish.image} alt={dish.name} />
                  <CardImgOverlay>
                      <CardTitle>{dish.name}</CardTitle>
                  </CardImgOverlay>
                </Card>
              </div>
            );
        });

        return (
            <div className="container">
                <div className="row">
                    {menu}
                </div>
                <div className="row">
                  <div  className="col-12 col-md-5 m-1">
                    {this.renderDish(this.state.selectedDish)}
                  </div>
                </div>
            </div>
        );
    }
  }
  . . .
  Add a folder named shared under the src folder.
  In the shared folder, create a new file named dishes.js and add the following content to it
  (Note: Alternately you can download the dishes.js file given above in the Exercise Resources and move it to the shared folder.
  Make sure the file is named dishes.js):
  export const DISHES =
    [
        {
        id: 0,
        name:'Uthappizza',
        image: 'assets/images/uthappizza.png',
        category: 'mains',
        label:'Hot',
        price:'4.99',
        description:'A unique combination of Indian Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer.',
        comments: [
            {
            id: 0,
            rating: 5,
            comment: "Imagine all the eatables, living in conFusion!",
            author: "John Lemon",
            date: "2012-10-16T17:57:28.556094Z"
            },
            {
            id: 1,
            rating: 4,
            comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
            author: "Paul McVites",
            date: "2014-09-05T17:57:28.556094Z"
            },
            {
            id: 2,
            rating: 3,
            comment: "Eat it, just eat it!",
            author: "Michael Jaikishan",
            date: "2015-02-13T17:57:28.556094Z"
            },
            {
            id: 3,
            rating: 4,
            comment: "Ultimate, Reaching for the stars!",
            author: "Ringo Starry",
            date: "2013-12-02T17:57:28.556094Z"
            },
            {
            id: 4,
            rating: 2,
            comment: "It's your birthday, we're gonna party!",
            author: "25 Cent",
            date: "2011-12-02T17:57:28.556094Z"
            }
        ]                        },
        {
        id: 1,
        name:'Zucchipakoda',
        image: 'assets/images/zucchipakoda.png',
        category: 'appetizer',
        label:'',
        price:'1.99',
        description:'Deep fried Zucchini coated with mildly spiced Chickpea flour batter accompanied with a sweet-tangy tamarind sauce',
        comments: [
            {
            id: 0,
            rating: 5,
            comment: "Imagine all the eatables, living in conFusion!",
            author: "John Lemon",
            date: "2012-10-16T17:57:28.556094Z"
            },
            {
            id: 1,
            rating: 4,
            comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
            author: "Paul McVites",
            date: "2014-09-05T17:57:28.556094Z"
            },
            {
            id: 2,
            rating: 3,
            comment: "Eat it, just eat it!",
            author: "Michael Jaikishan",
            date: "2015-02-13T17:57:28.556094Z"
            },
            {
            id: 3,
            rating: 4,
            comment: "Ultimate, Reaching for the stars!",
            author: "Ringo Starry",
            date: "2013-12-02T17:57:28.556094Z"
            },
            {
            id: 4,
            rating: 2,
            comment: "It's your birthday, we're gonna party!",
            author: "25 Cent",
            date: "2011-12-02T17:57:28.556094Z"
            }
        ]
        },
        {
        id: 2,
        name:'Vadonut',
        image: 'assets/images/vadonut.png',
        category: 'appetizer',
        label:'New',
        price:'1.99',
        description:'A quintessential ConFusion experience, is it a vada or is it a donut?',
        comments: [
            {
            id: 0,
            rating: 5,
            comment: "Imagine all the eatables, living in conFusion!",
            author: "John Lemon",
            date: "2012-10-16T17:57:28.556094Z"
            },
            {
            id: 1,
            rating: 4,
            comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
            author: "Paul McVites",
            date: "2014-09-05T17:57:28.556094Z"
            },
            {
            id: 2,
            rating: 3,
            comment: "Eat it, just eat it!",
            author: "Michael Jaikishan",
            date: "2015-02-13T17:57:28.556094Z"
            },
            {
            id: 3,
            rating: 4,
            comment: "Ultimate, Reaching for the stars!",
            author: "Ringo Starry",
            date: "2013-12-02T17:57:28.556094Z"
            },
            {
            id: 4,
            rating: 2,
            comment: "It's your birthday, we're gonna party!",
            author: "25 Cent",
            date: "2011-12-02T17:57:28.556094Z"
            }
        ]
        },
        {
        id: 3,
        name:'ElaiCheese Cake',
        image: 'assets/images/elaicheesecake.png',
        category: 'dessert',
        label:'',
        price:'2.99',
        description:'A delectable, semi-sweet New York Style Cheese Cake, with Graham cracker crust and spiced with Indian cardamoms',
        comments: [
            {
            id: 0,
            rating: 5,
            comment: "Imagine all the eatables, living in conFusion!",
            author: "John Lemon",
            date: "2012-10-16T17:57:28.556094Z"
            },
            {
            id: 1,
            rating: 4,
            comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
            author: "Paul McVites",
            date: "2014-09-05T17:57:28.556094Z"
            },
            {
            id: 2,
            rating: 3,
            comment: "Eat it, just eat it!",
            author: "Michael Jaikishan",
            date: "2015-02-13T17:57:28.556094Z"
            },
            {
            id: 3,
            rating: 4,
            comment: "Ultimate, Reaching for the stars!",
            author: "Ringo Starry",
            date: "2013-12-02T17:57:28.556094Z"
            },
            {
            id: 4,
            rating: 2,
            comment: "It's your birthday, we're gonna party!",
            author: "25 Cent",
            date: "2011-12-02T17:57:28.556094Z"
            }
        ]
        }
    ];
  Open App.js and update it as follows:
  . . .

  import { DISHES } from './shared/dishes';

  . . .

  class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      dishes: DISHES
    };
  }

  . . .

  <Menu dishes={this.state.dishes} />
  . . .
  Save the changes and do a Git commit with the message "Components Part 2".

Conclusions
In this exercise we used a list of Cards to display the information in the menu component.
Also we used a card to display the details of a selected dish.


Exercise (Instructions): Presentational and Container Components
Objectives and Outcomes

In this exercise we understand about how presentational components deal with the look and feel of the app and container components deal with the data and behavior. At the end of this exercise you will learn about:
1.Organizing your React app into presentational and container components
2.Enable your presentational components to be concerned with the look and feel of your app
3.Enable container components to deal with the state, provide the data and handle user interactions.

1.Add a Container Component
  Add a new component named MainComponent.js in the components folder and update its contents as follows:
  import React, { Component } from 'react';
  import { Navbar, NavbarBrand } from 'reactstrap';
  import Menu from './MenuComponent';
  import DishDetail from './DishdetailComponent';
  import { DISHES } from '../shared/dishes';

  class Main extends Component {

    constructor(props) {
      super(props);
      this.state = {
          dishes: DISHES,
          selectedDish: null
      };
    }

    onDishSelect(dishId) {
      this.setState({ selectedDish: dishId});
    }

    render() {
      return (
        <div>
          <Navbar dark color="primary">
            <div className="container">
              <NavbarBrand href="/">Ristorante Con Fusion</NavbarBrand>
            </div>
          </Navbar>
          <Menu dishes={this.state.dishes} onClick={(dishId) => this.onDishSelect(dishId)} />
          <DishDetail dish={this.state.dishes.filter((dish) => dish.id === this.state.selectedDish)[0]} />
        </div>
      );
    }
  }

  export default Main;

  Update the App.js by removing the state related information, and make use of Main Component to render the UI:
  . . .
  import Main from './components/MainComponent';

  class App extends Component {

    render() {
      return (
        <div className="App">
          <Main />
        </div>
      );
    }
  }

  . . .

2.Turn Menu Component into a Presentational Component
  Open MenuComponent.js and update its contents by removing the state and removing the DishdetailComponent reference,
  and make use of the onClick supplied by MainComponent through the props to deal with the clicking of a menu item:
  . . .

                    <Card key={dish.id}
                        onClick={() => this.props.onClick(dish.id)}>

  . . .

  The DishdetailComponent is already structured as a presentational component and hence needs no further update,
  except wrapping the return value from render() within a <div> with the className as container.
  To print out the date for a comment in a format more suitable for human readability, you can update your renderComment function with the code snippet shown below:
  {new Intl.DateTimeFormat('en-US', { year: 'numeric', month: 'short', day: '2-digit'}).format(new Date(Date.parse(comment.date)))}
  Save all the changes and do a Git commit with the message "Presentational and Container Components"

Conclusions
In this exercise you learnt how to structure your app into presentational and container components.

React life cycle methods:
1. getSnapshotBeforeUpdate => This may be needed in situations, for example, when you're scrolling, you have this scrollbar in a component
and you're scrolling and you want to remember the position of the scroll at the point
so that when the component re-renders then you will retain that scrolling position, then that would be useful for saving the information.


Exercise (Instructions): Functional Components
Objectives and Outcomes
In this lesson we explore the design of functional components in React.
We will reimplement both the MenuComponent and DishdetailComponent as pure functional components.
At the end of this exercise you will be able to:

1.Implement functional components in React
2.Illustrate the reimplementation of presentational components as pure functional components

1.Implementing Functional Components
  Open MenuComponent.js and update it as follows:
  import React from 'react';
  import { Card, CardImg, CardImgOverlay,
    CardTitle } from 'reactstrap';

    function RenderMenuItem ({dish, onClick}) {
        return (
            <Card
                onClick={() => onClick(dish.id)}>
                <CardImg width="100%" src={dish.image} alt={dish.name} />
                <CardImgOverlay>
                    <CardTitle>{dish.name}</CardTitle>
                </CardImgOverlay>
            </Card>
        );
    }

    const Menu = (props) => {

        const menu = props.dishes.map((dish) => {
            return (
                <div className="col-12 col-md-5 m-1"  key={dish.id}>
                    <RenderMenuItem dish={dish} onClick={props.onClick} />
                </div>
            );
        });

        return (
            <div className="container">
                <div className="row">
                    {menu}
                </div>
            </div>
        );
    }

  export default Menu;

  Then open DishdetailComponent.js and update it as follows:
  import React from 'react';
  import { Card, CardImg, CardText, CardBody,
    CardTitle } from 'reactstrap';


    function RenderDish({dish}) {

      . . .

    }

    function RenderComments({comments}) {

      . . .

    }

    const  DishDetail = (props) => {

      . . .

    }

  export default DishDetail;

  Save all the changes and do a Git commit with the message "Functional Components".

Conclusions
In this exercise we have learnt to implement our components as pure functional components.

Exercise (Instructions): Header and Footer
Objectives and Outcomes
In this exercise you will add in a header and a footer to our React application using two React components.
This will illustrate the use of multiple components put together form the application's view.
You will also add in the Font Awesome icons  and Bootstrap-social for use within your application.
At the end of this exercise you will be able to:
1.Use multiple components and their views to put together the view of the application.
2.Make use of Font Awesome icons and Bootstrap-social within your React application

1.Using Font Awesome Icons and Bootstrap-Social
  First use yarn or npm to fetch Font Awesome and Bootstrap-social to the project by typing the following at the prompt:
  yarn add font-awesome@4.7.0
  yarn add bootstrap-social@5.1.1

  Then, open index.js file and update it as follows to enable your application to use Font Awesome and Bootstrap Social:
  . . .
  import 'font-awesome/css/font-awesome.css';
  import 'bootstrap-social/bootstrap-social.css';
  . . .

2. Adding a Header and a Footer
  Create a new file named HeaderComponent.js and add the following to it:
  import React, { Component } from 'react';
  import { Navbar, NavbarBrand, Jumbotron } from 'reactstrap';

  class Header extends Component {
    render() {
      return(
      <React.Fragment>
        <Navbar dark>
          <div className="container">
              <NavbarBrand href="/">Ristorante Con Fusion</NavbarBrand>
          </div>
        </Navbar>
        <Jumbotron>
            <div className="container">
                <div className="row row-header">
                    <div className="col-12 col-sm-6">
                        <h1>Ristorante con Fusion</h1>
                        <p>We take inspiration from the World's best cuisines, and create a unique fusion experience. Our lipsmacking creations will tickle your culinary senses!</p>
                    </div>
                </div>
            </div>
        </Jumbotron>
      </React.Fragment>
      );
    }
  }

  export default Header;

  Then, add another file named FooterComponent.js and add the following to it:
  import React from 'react';

  function Footer(props) {
      return(
      <div className="footer">
          <div className="container">
              <div className="row justify-content-center">
                  <div className="col-4 offset-1 col-sm-2">
                      <h5>Links</h5>
                      <ul className="list-unstyled">
                          <li><a href="#">Home</a></li>
                          <li><a href="#">About</a></li>
                          <li><a href="#">Menu</a></li>
                          <li><a href="contactus.html">Contact</a></li>
                      </ul>
                  </div>
                  <div className="col-7 col-sm-5">
                      <h5>Our Address</h5>
                      <address>
                    121, Clear Water Bay Road<br />
                    Clear Water Bay, Kowloon<br />
                    HONG KONG<br />
                    <i className="fa fa-phone fa-lg"></i>: +852 1234 5678<br />
                    <i className="fa fa-fax fa-lg"></i>: +852 8765 4321<br />
                    <i className="fa fa-envelope fa-lg"></i>: <a href="mailto:confusion@food.net">
                          confusion@food.net</a>
                      </address>
                  </div>
                  <div className="col-12 col-sm-4 align-self-center">
                      <div className="text-center">
                          <a className="btn btn-social-icon btn-google" href="http://google.com/+"><i className="fa fa-google-plus"></i></a>
                          <a className="btn btn-social-icon btn-facebook" href="http://www.facebook.com/profile.php?id="><i className="fa fa-facebook"></i></a>
                          <a className="btn btn-social-icon btn-linkedin" href="http://www.linkedin.com/in/"><i className="fa fa-linkedin"></i></a>
                          <a className="btn btn-social-icon btn-twitter" href="http://twitter.com/"><i className="fa fa-twitter"></i></a>
                          <a className="btn btn-social-icon btn-google" href="http://youtube.com/"><i className="fa fa-youtube"></i></a>
                          <a className="btn btn-social-icon" href="mailto:"><i className="fa fa-envelope-o"></i></a>
                      </div>
                  </div>
              </div>
              <div className="row justify-content-center">
                  <div className="col-auto">
                      <p>Â© Copyright 2018 Ristorante Con Fusion</p>
                  </div>
              </div>
          </div>
      </div>
      )
  }

  export default Footer;

3.Integrating Header and Footer into the React Application
  Now we open MainComponent.js and update it to integrate the header and footer into our application:
  . . .

  import Header from './HeaderComponent';
  import Footer from './FooterComponent';

  . . .

        <Header />
        <Menu dishes={this.state.dishes} onClick={(dishId) => this.onDishSelect(dishId)} />
        <DishDetail dish={this.state.dishes.filter((dish) => dish.id === this.state.selectedDish)[0]} />
        <Footer />

  . . .

  Then update App.css to add some new CSS classes for use in our application:
  .row-header{
      margin:0px auto;
      padding:0px auto;
  }

  .row-content {
      margin:0px auto;
      padding: 50px 0px 50px 0px;
      border-bottom: 1px ridge;
      min-height:400px;
  }

  .footer{
      background-color: #D1C4E9;
      margin:0px auto;
      padding: 20px 0px 20px 0px;
  }
  .jumbotron {
      padding:70px 30px 70px 30px;
      margin:0px auto;
      background: #9575CD ;
      color:floralwhite;
  }

  address{
      font-size:80%;
      margin:0px;
      color:#0f0f0f;
  }

  .navbar-dark {
      background-color: #512DA8;
  }

  Save all the changes and do a Git commit with the message "Header and Footer"

Conclusions
In this exercise we updated the React application to use Font Awesome and Bootstrap Social, and also integrated two new components, Header and Footer, into our application.

Exercise (Instructions): React Router
Objectives and Outcomes
In this exercise we learn to use the React Router to configure and set up navigation among various pages in a React application. At the end of this exercise you will be able to:
1.Install and configure your application to use React Router
2.Configure the routes for React router to enable you to navigate to various pages within your React application

1.Installing and Configuring React Router
  First install React Router into your project by typing the following at the prompt:
  yarn add react-router-dom@4.2.2

  Then, open App.js and update it as follows:
  . . .

  import { BrowserRouter } from 'react-router-dom';

  . . .

      <BrowserRouter>
        <div className="App">
          <Main />
        </div>
      </BrowserRouter>

  . . .

2. Add a Home Component
  Create a new file named HomeComponent.js in the components folder and add the following to it:
  import React from 'react';

  function Home(props) {
      return(
        <div className="container">
          <h4>Home</h4>
        </div>
      );
  }

  export default Home;

3.Configuring the Router
  Open MainComponent.js file and update it as follows:
  . . .

  import Home from './HomeComponent';

  . . .

  import { Switch, Route, Redirect } from 'react-router-dom';

  . . .

    render() {


      const HomePage = () => {
        return(
            <Home
            />
        );
      }

  . . .

          <Switch>
              <Route path='/home' component={HomePage} />
              <Route exact path='/menu' component={() => <Menu dishes={this.state.dishes} />} />
              <Redirect to="/home" />
          </Switch>

  . . .

  Open HeaderComponent.js and update its contents with the following:
  import { Nav, Navbar, NavbarBrand, NavbarToggler, Collapse, NavItem, Jumbotron } from 'reactstrap';
  import { NavLink } from 'react-router-dom';

  class Header extends Component {
      constructor(props) {
          super(props);

          this.toggleNav = this.toggleNav.bind(this);
          this.state = {
            isNavOpen: false
          };
        }

        toggleNav() {
          this.setState({
            isNavOpen: !this.state.isNavOpen
          });
        }

      render() {
          return(
              <div>
                  <Navbar dark expand="md">
                      <div className="container">
                          <NavbarToggler onClick={this.toggleNav} />
                          <NavbarBrand className="mr-auto" href="/"><img src='assets/images/logo.png' height="30" width="41" alt='Ristorante Con Fusion' /></NavbarBrand>
                          <Collapse isOpen={this.state.isNavOpen} navbar>
                              <Nav navbar>
                              <NavItem>
                                  <NavLink className="nav-link"  to='/home'><span className="fa fa-home fa-lg"></span> Home</NavLink>
                              </NavItem>
                              <NavItem>
                                  <NavLink className="nav-link" to='/aboutus'><span className="fa fa-info fa-lg"></span> About Us</NavLink>
                              </NavItem>
                              <NavItem>
                                  <NavLink className="nav-link"  to='/menu'><span className="fa fa-list fa-lg"></span> Menu</NavLink>
                              </NavItem>
                              <NavItem>
                                  <NavLink className="nav-link" to='/contactus'><span className="fa fa-address-card fa-lg"></span> Contact Us</NavLink>
                              </NavItem>
                              </Nav>
                          </Collapse>
                      </div>
                  </Navbar>
                  <Jumbotron>
                      <div className="container">
                          <div className="row row-header">
                              <div className="col-12 col-sm-6">
                                  <h1>Ristorante con Fusion</h1>
                                  <p>We take inspiration from the World's best cuisines, and create a unique fusion experience. Our lipsmacking creations will tickle your culinary senses!</p>
                              </div>
                          </div>
                      </div>
                  </Jumbotron>
              </div>
          );
      }
  }

  Then, open FooterComponent.js and update it as follows:
  . . .

  import { Link } from 'react-router-dom';

  . . .

                          <li><Link to='/home'>Home</Link></li>
                          <li><Link to='/aboutus'>About Us</Link></li>
                          <li><Link to='/menu'>Menu</Link></li>
                          <li><Link to='/contactus'>Contact Us</Link></li>

  . . .

  Open MenuComponent.js and remove the onClick() from the Card in the RenderMenuItem() function.
  Save all the changes and do a Git commit with the message "React Router".

Conclusions
In this exercise you learn about installing, configuring and using the React Router for navigation within your React app.

Exercise (Instructions): Single Page Applications Part 1
Objectives and Outcomes
In this exercise you will continue to develop the React application as a single page application, integrating the various components.
At the end of this exercise you will be able to:
  1.Leverage the React router to enable the development of single page applications
  2.Provide a way of navigating among various pages using the React router support.

1.Integrating the Contact Component
  Add a new file named ContactComponent.js file and update its contents as follows:
  import React from 'react';

  function Contact(props) {
      return(
          <div className="container">
              <div className="row row-content">
                  <div className="col-12">
                  <h3>Location Information</h3>
                  </div>
                  <div className="col-12 col-sm-4 offset-sm-1">
                          <h5>Our Address</h5>
                          <address>
                          121, Clear Water Bay Road<br />
                          Clear Water Bay, Kowloon<br />
                          HONG KONG<br />
                          <i className="fa fa-phone"></i>: +852 1234 5678<br />
                          <i className="fa fa-fax"></i>: +852 8765 4321<br />
                          <i className="fa fa-envelope"></i>: <a href="mailto:confusion@food.net">confusion@food.net</a>
                          </address>
                  </div>
                  <div className="col-12 col-sm-6 offset-sm-1">
                      <h5>Map of our Location</h5>
                  </div>
                  <div className="col-12 col-sm-11 offset-sm-1">
                      <div className="btn-group" role="group">
                          <a role="button" className="btn btn-primary" href="tel:+85212345678"><i className="fa fa-phone"></i> Call</a>
                          <a role="button" className="btn btn-info"><i className="fa fa-skype"></i> Skype</a>
                          <a role="button" className="btn btn-success" href="mailto:confusion@food.net"><i className="fa fa-envelope-o"></i> Email</a>
                      </div>
                  </div>
              </div>
          </div>
      );
  }

  export default Contact;

  Update the MainComponent.js file to integrate the ContactComponent by adding in the following:
  . . .

  import Contact from './ContactComponent';

  . . .

              <Route exact path='/contactus' component={Contact} />} />

2. Updating the Home Component
  First update dishes.js file in the shared folder to update the dishes as follows. (NOTE: Alternately you can download dishes.js, comments.js, promotions.js and leaders.js given above in Exercise resources and move them to the shared folder):
  export const DISHES =
    [
        {
        id: 0,
        name:'Uthappizza',
        image: '/assets/images/uthappizza.png',
        category: 'mains',
        label:'Hot',
        price:'4.99',
        featured: true,
        description:'A unique combination of Indian Uthappam (pancake) and Italian pizza, topped with Cerignola olives, ripe vine cherry tomatoes, Vidalia onion, Guntur chillies and Buffalo Paneer.'
        },
        {
        id: 1,
        name:'Zucchipakoda',
        image: '/assets/images/zucchipakoda.png',
        category: 'appetizer',
        label:'',
        price:'1.99',
        featured: false,
        description:'Deep fried Zucchini coated with mildly spiced Chickpea flour batter accompanied with a sweet-tangy tamarind sauce'
        },
        {
        id: 2,
        name:'Vadonut',
        image: '/assets/images/vadonut.png',
        category: 'appetizer',
        label:'New',
        price:'1.99',
        featured: false,
        description:'A quintessential ConFusion experience, is it a vada or is it a donut?'
        },
        {
        id: 3,
        name:'ElaiCheese Cake',
        image: '/assets/images/elaicheesecake.png',
        category: 'dessert',
        label:'',
        price:'2.99',
        featured: false,
        description:'A delectable, semi-sweet New York Style Cheese Cake, with Graham cracker crust and spiced with Indian cardamoms'
        }
    ];

  Now add a new file named comments.js to the shared folder and update it as follows. We are now moving the comments about the dishes into its own file:
  export const COMMENTS =
  [
      {
          id: 0,
          dishId: 0,
          rating: 5,
          comment: "Imagine all the eatables, living in conFusion!",
          author: "John Lemon",
          date: "2012-10-16T17:57:28.556094Z"
      },
      {
          id: 1,
          dishId: 0,
          rating: 4,
          comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
          author: "Paul McVites",
          date: "2014-09-05T17:57:28.556094Z"
      },
      {
          id: 2,
          dishId: 0,
          rating: 3,
          comment: "Eat it, just eat it!",
          author: "Michael Jaikishan",
          date: "2015-02-13T17:57:28.556094Z"
      },
      {
          id: 3,
          dishId: 0,
          rating: 4,
          comment: "Ultimate, Reaching for the stars!",
          author: "Ringo Starry",
          date: "2013-12-02T17:57:28.556094Z"
      },
      {
          id: 4,
          dishId: 0,
          rating: 2,
          comment: "It's your birthday, we're gonna party!",
          author: "25 Cent",
          date: "2011-12-02T17:57:28.556094Z"
      },
      {
          id: 5,
          dishId: 1,
          rating: 5,
          comment: "Imagine all the eatables, living in conFusion!",
          author: "John Lemon",
          date: "2012-10-16T17:57:28.556094Z"
      },
      {
          id: 6,
          dishId: 1,
          rating: 4,
          comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
          author: "Paul McVites",
          date: "2014-09-05T17:57:28.556094Z"
      },
      {
          id: 7,
          dishId: 1,
          rating: 3,
          comment: "Eat it, just eat it!",
          author: "Michael Jaikishan",
          date: "2015-02-13T17:57:28.556094Z"
      },
      {
          id: 8,
          dishId: 1,
          rating: 4,
          comment: "Ultimate, Reaching for the stars!",
          author: "Ringo Starry",
          date: "2013-12-02T17:57:28.556094Z"
      },
      {
          id: 9,
          dishId: 1,
          rating: 2,
          comment: "It's your birthday, we're gonna party!",
          author: "25 Cent",
          date: "2011-12-02T17:57:28.556094Z"
      },
      {
          id: 10,
          dishId: 2,
          rating: 5,
          comment: "Imagine all the eatables, living in conFusion!",
          author: "John Lemon",
          date: "2012-10-16T17:57:28.556094Z"
      },
      {
          id: 11,
          dishId: 2,
          rating: 4,
          comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
          author: "Paul McVites",
          date: "2014-09-05T17:57:28.556094Z"
      },
      {
          id: 12,
          dishId: 2,
          rating: 3,
          comment: "Eat it, just eat it!",
          author: "Michael Jaikishan",
          date: "2015-02-13T17:57:28.556094Z"
      },
      {
          id: 13,
          dishId: 2,
          rating: 4,
          comment: "Ultimate, Reaching for the stars!",
          author: "Ringo Starry",
          date: "2013-12-02T17:57:28.556094Z"
      },
      {
          id: 14,
          dishId: 2,
          rating: 2,
          comment: "It's your birthday, we're gonna party!",
          author: "25 Cent",
          date: "2011-12-02T17:57:28.556094Z"
      },
      {
          id: 15,
          dishId: 3,
          rating: 5,
          comment: "Imagine all the eatables, living in conFusion!",
          author: "John Lemon",
          date: "2012-10-16T17:57:28.556094Z"
      },
      {
          id: 16,
          dishId: 3,
          rating: 4,
          comment: "Sends anyone to heaven, I wish I could get my mother-in-law to eat it!",
          author: "Paul McVites",
          date: "2014-09-05T17:57:28.556094Z"
      },
      {
          id: 17,
          dishId: 3,
          rating: 3,
          comment: "Eat it, just eat it!",
          author: "Michael Jaikishan",
          date: "2015-02-13T17:57:28.556094Z"
      },
      {
          id: 18,
          dishId: 3,
          rating: 4,
          comment: "Ultimate, Reaching for the stars!",
          author: "Ringo Starry",
          date: "2013-12-02T17:57:28.556094Z"
      },
      {
          id: 19,
          dishId: 3,
          rating: 2,
          comment: "It's your birthday, we're gonna party!",
          author: "25 Cent",
          date: "2011-12-02T17:57:28.556094Z"
      }
  ];

  Next add a new file named promotions.js file to the shared folder and update its contents as follows:
  export const PROMOTIONS = [
    {
      id: 0,
      name: 'Weekend Grand Buffet',
      image: '/assets/images/buffet.png',
      label: 'New',
      price: '19.99',
      featured: true,
      description: 'Featuring mouthwatering combinations with a choice of five different salads, six enticing appetizers, six main entrees and five choicest desserts. Free flowing bubbly and soft drinks. All for just $19.99 per person'
    }
  ];

  Next add a new file named leaders.js file to the shared folder and update its contents as follows:
  export const LEADERS = [
    {
      id: 0,
      name: 'Peter Pan',
      image: '/assets/images/alberto.png',
      designation: 'Chief Epicurious Officer',
      abbr: 'CEO',
      featured: false,
      description: "Our CEO, Peter, credits his hardworking East Asian immigrant parents who undertook the arduous journey to the shores of America with the intention of giving their children the best future. His mother's wizardy in the kitchen whipping up the tastiest dishes with whatever is available inexpensively at the supermarket, was his first inspiration to create the fusion cuisines for which The Frying Pan became well known. He brings his zeal for fusion cuisines to this restaurant, pioneering cross-cultural culinary connections."
    },
    {
      id: 1,
      name: 'Dhanasekaran Witherspoon',
      image: '/assets/images/alberto.png',
      designation: 'Chief Food Officer',
      abbr: 'CFO',
        featured: false,
      description: 'Our CFO, Danny, as he is affectionately referred to by his colleagues, comes from a long established family tradition in farming and produce. His experiences growing up on a farm in the Australian outback gave him great appreciation for varieties of food sources. As he puts it in his own words, Everything that runs, wins, and everything that stays, pays!'
    },
    {
      id: 2,
      name: 'Agumbe Tang',
      image: '/assets/images/alberto.png',
      designation: 'Chief Taste Officer',
      abbr: 'CTO',
        featured: false,
      description: 'Blessed with the most discerning gustatory sense, Agumbe, our CFO, personally ensures that every dish that we serve meets his exacting tastes. Our chefs dread the tongue lashing that ensues if their dish does not meet his exacting standards. He lives by his motto, You click only if you survive my lick.'
    },
    {
      id: 3,
      name: 'Alberto Somayya',
      image: '/assets/images/alberto.png',
      designation: 'Executive Chef',
      abbr: 'EC',
      featured: true,
      description: 'Award winning three-star Michelin chef with wide International experience having worked closely with whos-who in the culinary world, he specializes in creating mouthwatering Indo-Italian fusion experiences. He says, Put together the cuisines from the two craziest cultures, and you get a winning hit! Amma Mia!'
    }
  ];

  Now update the HomeComponent.ts file to fetch and display the featured dish, promotion and leader as follows:
  import React from 'react';
  import { Card, CardImg, CardText, CardBody,
    CardTitle, CardSubtitle} from 'reactstrap';

  function RenderCard({item}) {

      return(
          <Card>
              <CardImg src={item.image} alt={item.name} />
              <CardBody>
              <CardTitle>{item.name}</CardTitle>
              {item.designation ? <CardSubtitle>{item.designation}</CardSubtitle> : null }
              <CardText>{item.description}</CardText>
              </CardBody>
          </Card>
      );

  }

  function Home(props) {
      return(
          <div className="container">
              <div className="row align-items-start">
                  <div className="col-12 col-md m-1">
                      <RenderCard item={props.dish} />
                  </div>
                  <div className="col-12 col-md m-1">
                      <RenderCard item={props.promotion} />
                  </div>
                  <div className="col-12 col-md m-1">
                      <RenderCard item={props.leader} />
                  </div>
              </div>
          </div>
      );
  }

  export default Home;

  Next, update MainComponent.js as follows:
  . . .

  import { COMMENTS } from '../shared/comments';
  import { PROMOTIONS } from '../shared/promotions';
  import { LEADERS } from '../shared/leaders';

  . . .

  class Main extends Component {

    constructor(props) {
      super(props);

      this.state = {
        dishes: DISHES,
        comments: COMMENTS,
        promotions: PROMOTIONS,
        leaders: LEADERS
      };
    }

    . . .

      const HomePage = () => {
        return(
            <Home
                dish={this.state.dishes.filter((dish) => dish.featured)[0]}
                promotion={this.state.promotions.filter((promo) => promo.featured)[0]}
                leader={this.state.leaders.filter((leader) => leader.featured)[0]}
            />
        );
      }

  . . .

  Save all the changes and do a Git commit with the message "Single Page Applications Part 1".

Conclusions
In this exercise you developed the Angular application further by integrating the components into a single page application.

Exercise (Instructions): Single Page Applications Part 2
Objectives and Outcomes
In this exercise you will integrate the DishdetailComponent into your single page application.
You will use a route parameter in the URL to pass in the details of the selected dish to the DishdetailComponent.
At the end of this exercise you will be able to:
1.Configure the routes in your React router configuration to enable the use of route parameters within the URL to pass information to a component.

1.Updating to Use Parameters on Routes
  Open MenuComponent.js and add the following changes to it to enable the information about the selected dish to be passed to the DishdetailComponent:
  . . .

  import { Card, CardImg, CardImgOverlay,
      CardTitle, Breadcrumb, BreadcrumbItem } from 'reactstrap';
  import { Link } from 'react-router-dom';

    function RenderMenuItem ({dish, onClick}) {
        return (
            <Card>
                <Link to={`/menu/${dish.id}`} >
                    <CardImg width="100%" src={dish.image} alt={dish.name} />
                    <CardImgOverlay>
                        <CardTitle>{dish.name}</CardTitle>
                    </CardImgOverlay>
                </Link>
            </Card>
        );
    }

  . . .

        return (
            <div className="container">
                <div className="row">
                    <Breadcrumb>
                        <BreadcrumbItem><Link to="/home">Home</Link></BreadcrumbItem>
                        <BreadcrumbItem active>Menu</BreadcrumbItem>
                    </Breadcrumb>
                    <div className="col-12">
                        <h3>Menu</h3>
                        <hr />
                    </div>
                </div>
                <div className="row">
                    {menu}
                </div>
            </div>
        );

  . . .

  Open MainComponent.js and update it as follows:
  . . .


    const DishWithId = ({match}) => {
      return(
          <DishDetail dish={this.state.dishes.filter((dish) => dish.id === parseInt(match.params.dishId,10))[0]}
            comments={this.state.comments.filter((comment) => comment.dishId === parseInt(match.params.dishId,10))} />
      );
    };

  . . .

              <Route path='/menu/:dishId' component={DishWithId} />

  . . .

2. Updating DishDetail Component
  Open DishdetailComponent.js and update it as follows:
  . . .

  import { Card, CardImg, CardText, CardBody,
      CardTitle, Breadcrumb, BreadcrumbItem } from 'reactstrap';
  import { Link } from 'react-router-dom';
  . . .

            return (
                <div className="container">
                <div className="row">
                    <Breadcrumb>

                        <BreadcrumbItem><Link to="/menu">Menu</Link></BreadcrumbItem>
                        <BreadcrumbItem active>{props.dish.name}</BreadcrumbItem>
                    </Breadcrumb>
                    <div className="col-12">
                        <h3>{props.dish.name}</h3>
                        <hr />
                    </div>
                </div>
                <div className="row">
                    <div className="col-12 col-md-5 m-1">
                        <RenderDish dish={props.dish} />
                    </div>
                    <div className="col-12 col-md-5 m-1">
                        <RenderComments comments={props.comments} />
                    </div>
                </div>
                </div>
            );

  . . .

3.Adding Breadcrumbs to ContactComponent
  Open ContactComponent.js and add Breadcrumbs to it as follows:
  . . .

  import { Breadcrumb, BreadcrumbItem } from 'reactstrap';
  import { Link } from 'react-router-dom';

  . . .

            <div className="row">
                <Breadcrumb>
                    <BreadcrumbItem><Link to="/home">Home</Link></BreadcrumbItem>
                    <BreadcrumbItem active>Contact Us</BreadcrumbItem>
                </Breadcrumb>
                <div className="col-12">
                    <h3>Contact Us</h3>
                    <hr />
                </div>
            </div>
  . . .
  Save all the changes and do a Git commit with the message "Single Page Applications Part 2".

Conclusions
In this exercise you have seen the use of parameters within the URL to pass information to another component.

Assignment 2 ReactRouter and Single Page Applications:

In this assignment you will continue working with the React application by adding a new component named AboutComponent to serve up the details of the corporate leaders,
and you will then integrate the AboutComponent into the single page application.

Objectives and Outcomes
At the end of this assignment, you should have completed the following tasks:
1.Integrated the AboutComponent given above into the single page application.
2.Added a new functional component named <RenderLeader> through the RenderLeader() function to AboutComponent.js that renders the details of a given leader using the reactstrap <Media> component.
3.Construct and render the list of leaders in the About Us page using the <RenderLeader> component implemented above.

Assignment Requirements
This assignment requires you to complete the following tasks.
Detailed instructions for each task are given below.
The picture of the completed web page included below indicates the location within the web page that will be updated by the three tasks.

Task 1
In this task you will be integrating the AboutComponent into the single page application:
First, download the AboutComponent.js given above and move it to the components folder, and
Update the MainComponent.js file to integrate the AboutComponent into the single page application. You should be able to navigate to the AboutComponent by clicking the links in the navigation bar and the footer.

Task 2
In this task you will implement a new functional component named <RenderLeader> through the RenderLeader() function:
The RenderLeader() function receives the details of a leader as its  parameter,
Implement RenderLeader() function to use the Leader information received as a parameter and render the leader information as shown in the screenshot below using the reactstrap <Media> component. Recall how we used the <Media> component in the first module to render the details of a dish in the MenuComponent.
This will make available the <RenderLeader> component for use within your AboutComponent.

Task 3
In this task you will use the <RenderLeader> component created in the previous task to render a list of leaders within your AboutComponent:
Update the leaders variable within the AboutComponent() function to make use of the <RenderLeader> component to render the list of leaders.


Exercise (Instructions): Controlled Forms
Objectives and Outcomes
In this exercise you will learn about using controlled components to design controlled forms in your React application.
At the end of this exercise you will be able to:
  Design a controlled form in your React application.

1.Importing the Necessary Components
  You will start out by importing the necessary components from reactstrap into ContactComponent.js as follows:
  . . .

  import React, { Component } from 'react';
  import { Breadcrumb, BreadcrumbItem,
            Button, Form, FormGroup, Label, Input, Col } from 'reactstrap';

  . . .

  You will then change the ContactComponent to a class-based component as follows:
  . . .

  class Contact extends Component {

    render() {

      . . .

    }

  }

2. Creating the Controlled Form
  Update the ContactComponent.js file as follows to set up the Controlled Form:
  . . .

    constructor(props) {
        super(props);

        this.state = {
            firstname: '',
            lastname: '',
            telnum: '',
            email: '',
            agree: false,
            contactType: 'Tel.',
            message: ''
        };

        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);

    }

    handleInputChange(event) {
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;

        this.setState({
          [name]: value
        });
    }

    handleSubmit(event) {
        console.log('Current State is: ' + JSON.stringify(this.state));
        alert('Current State is: ' + JSON.stringify(this.state));
        event.preventDefault();
    }

  . . .

  Then add the controlled form to it as follows:
  . . .

                <div className="row row-content">
                   <div className="col-12">
                      <h3>Send us your Feedback</h3>
                   </div>
                    <div className="col-12 col-md-9">
                        <Form onSubmit={this.handleSubmit}>
                            <FormGroup row>
                                <Label htmlFor="firstname" md={2}>First Name</Label>
                                <Col md={10}>
                                    <Input type="text" id="firstname" name="firstname"
                                        placeholder="First Name"
                                        value={this.state.firstname}
                                        onChange={this.handleInputChange} />
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="lastname" md={2}>Last Name</Label>
                                <Col md={10}>
                                    <Input type="text" id="lastname" name="lastname"
                                        placeholder="Last Name"
                                        value={this.state.lastname}
                                        onChange={this.handleInputChange} />
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                            <Label htmlFor="telnum" md={2}>Contact Tel.</Label>
                                <Col md={10}>
                                    <Input type="tel" id="telnum" name="telnum"
                                        placeholder="Tel. number"
                                        value={this.state.telnum}
                                        onChange={this.handleInputChange} />
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="email" md={2}>Email</Label>
                                <Col md={10}>
                                    <Input type="email" id="email" name="email"
                                        placeholder="Email"
                                        value={this.state.email}
                                        onChange={this.handleInputChange} />
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Col md={{size: 6, offset: 2}}>
                                    <FormGroup check>
                                        <Label check>
                                            <Input type="checkbox"
                                                name="agree"
                                                checked={this.state.agree}
                                                onChange={this.handleInputChange} /> {' '}
                                            <strong>May we contact you?</strong>
                                        </Label>
                                    </FormGroup>
                                </Col>
                                <Col md={{size: 3, offset: 1}}>
                                    <Input type="select" name="contactType"
                                            value={this.state.contactType}
                                            onChange={this.handleInputChange}>
                                        <option>Tel.</option>
                                        <option>Email</option>
                                    </Input>
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="message" md={2}>Your Feedback</Label>
                                <Col md={10}>
                                    <Input type="textarea" id="message" name="message"
                                        rows="12"
                                        value={this.state.message}
                                        onChange={this.handleInputChange}></Input>
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Col md={{size: 10, offset: 2}}>
                                    <Button type="submit" color="primary">
                                        Send Feedback
                                    </Button>
                                </Col>
                            </FormGroup>
                        </Form>
                    </div>
               </div>

  . . .
  Save all changes and do a Git commit with the message "Controlled Forms".

Conclusions
In this exercise you have learnt to create a controlled form within your React application.


Exercise (Instructions): Controlled Form Validation
Objectives and Outcomes
In this exercise you will be introduced to simple form validation for controlled forms in React.
At the end of this exercise you will be able to:
  Configure and perform simple form validation for your controlled forms

1.Simple Form Validation
  Open ContactComponent.js and update it as follows to introduce the support to track form errors and perform validation:
  . . .
  import { Breadcrumb, BreadcrumbItem, Button, Form, FormGroup, Label, Input, Col, Row, FormFeedback } from 'reactstrap';
  . . .

  class Contact extends Component {

      constructor(props) {
          super(props);

          this.state = {
              firstname: '',
              lastname: '',
              telnum: '',
              email: '',
              agree: false,
              contactType: 'Tel.',
              message: '',
              touched: {
                  firstname: false,
                  lastname: false,
                  telnum: false,
                  email: false
              }
          }
          this.handleSubmit = this.handleSubmit.bind(this);
          this.handleInputChange = this.handleInputChange.bind(this);
          this.handleBlur = this.handleBlur.bind(this);
      }

      . . .

      handleBlur = (field) => (evt) => {
          this.setState({
              touched: { ...this.state.touched, [field]: true }
          });
      }

      validate(firstname, lastname, telnum, email) {
          const errors = {
              firstname: '',
              lastname: '',
              telnum: '',
              email: ''
          };

          if (this.state.touched.firstname && firstname.length < 3)
              errors.firstname = 'First Name should be >= 3 characters';
          else if (this.state.touched.firstname && firstname.length > 10)
              errors.firstname = 'First Name should be <= 10 characters';

          if (this.state.touched.lastname && lastname.length < 3)
              errors.lastname = 'Last Name should be >= 3 characters';
          else if (this.state.touched.lastname && lastname.length > 10)
              errors.lastname = 'Last Name should be <= 10 characters';

          const reg = /^\d+$/;
          if (this.state.touched.telnum && !reg.test(telnum))
              errors.telnum = 'Tel. Number should contain only numbers';

          if(this.state.touched.email && email.split('').filter(x => x === '@').length !== 1)
              errors.email = 'Email should contain a @';

          return errors;
      }

      . . .

    render() {
          const errors = this.validate(this.state.firstname, this.state.lastname, this.state.telnum, this.state.email);

          . . .
  Now that we have introduced some functions that can be used for form validation, let us update the form itself to make use of these as follows:
  . . .

                            <FormGroup row>
                                <Label htmlFor="firstname" md={2}>First Name</Label>
                                <Col md={10}>
                                    <Input type="text" id="firstname" name="firstname"
                                        placeholder="First Name"
                                        value={this.state.firstname}
                                        valid={errors.firstname === ''}
                                        invalid={errors.firstname !== ''}
                                        onBlur={this.handleBlur('firstname')}
                                        onChange={this.handleInputChange} />
                                    <FormFeedback>{errors.firstname}</FormFeedback>
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="lastname" md={2}>Last Name</Label>
                                <Col md={10}>
                                    <Input type="text" id="lastname" name="lastname"
                                        placeholder="Last Name"
                                        value={this.state.lastname}
                                        valid={errors.lastname === ''}
                                        invalid={errors.lastname !== ''}
                                        onBlur={this.handleBlur('lastname')}
                                        onChange={this.handleInputChange} />
                                    <FormFeedback>{errors.lastname}</FormFeedback>
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="telnum" md={2}>Contact Tel.</Label>
                                <Col md={10}>
                                    <Input type="tel" id="telnum" name="telnum"
                                        placeholder="Tel. Number"
                                        value={this.state.telnum}
                                        valid={errors.telnum === ''}
                                        invalid={errors.telnum !== ''}
                                        onBlur={this.handleBlur('telnum')}
                                        onChange={this.handleInputChange} />
                                    <FormFeedback>{errors.telnum}</FormFeedback>
                                </Col>
                            </FormGroup>
                            <FormGroup row>
                                <Label htmlFor="email" md={2}>Email</Label>
                                <Col md={10}>
                                    <Input type="email" id="email" name="email"
                                        placeholder="Email"
                                        value={this.state.email}
                                        valid={errors.email === ''}
                                        invalid={errors.email !== ''}
                                        onBlur={this.handleBlur('email')}
                                        onChange={this.handleInputChange} />
                                    <FormFeedback>{errors.email}</FormFeedback>
                                </Col>
                            </FormGroup>

  . . .

  You can now test your form by typing in invalid input and check how the form validation works.
  Save all the changes and do a Git commit with the message "Controlled Form Validation"

Conclusions
In this exercise you have learnt about doing simple form validation for controlled forms in React.

Exercise (Instructions): Uncontrolled Forms
In this exercise we will create an uncontrolled form within our React application using the uncontrolled component approach. At the end of this exercise you will be able to:

1.Create uncontrolled forms through uncontrolled components in React
2.Handle the form submission in the React application

1.Adding a Modal to Host the Form
  Update HeaderComponent.js as follows to add a new Modal to the application to host the form:
  . . .

  import { Navbar, NavbarBrand, Nav, NavbarToggler, Collapse, NavItem, Jumbotron,
      Button, Modal, ModalHeader, ModalBody,
      Form, FormGroup, Input, Label } from 'reactstrap';

  . . .

        this.state = {
            isNavOpen: false,
            isModalOpen: false
        };

  . . .

        this.toggleModal = this.toggleModal.bind(this);

  . . .


      toggleModal() {
        this.setState({
          isModalOpen: !this.state.isModalOpen
        });
      }

  . . .

                <Modal isOpen={this.state.isModalOpen} toggle={this.toggleModal}>
                    <ModalHeader toggle={this.toggleModal}>Login</ModalHeader>
                    <ModalBody>

                    </ModalBody>
                </Modal>

  . . .

  Then, add a button to the Navbar to enable toggling the modal:
  . . .

                            <Nav className="ml-auto" navbar>
                                <NavItem>
                                    <Button outline onClick={this.toggleModal}><span className="fa fa-sign-in fa-lg"></span> Login</Button>
                                </NavItem>
                            </Nav>

  . . .

2.Adding the Uncontrolled Form
  Add the form to the modal body as shown below:
  . . .

                        <Form onSubmit={this.handleLogin}>
                            <FormGroup>
                                <Label htmlFor="username">Username</Label>
                                <Input type="text" id="username" name="username"
                                    innerRef={(input) => this.username = input} />
                            </FormGroup>
                            <FormGroup>
                                <Label htmlFor="password">Password</Label>
                                <Input type="password" id="password" name="password"
                                    innerRef={(input) => this.password = input}  />
                            </FormGroup>
                            <FormGroup check>
                                <Label check>
                                    <Input type="checkbox" name="remember"
                                    innerRef={(input) => this.remember = input}  />
                                    Remember me
                                </Label>
                            </FormGroup>
                            <Button type="submit" value="submit" color="primary">Login</Button>
                        </Form>

  . . .
  Then, add the following function to the class to handle the form submission:
  . . .

        this.handleLogin = this.handleLogin.bind(this);
  . . .

    handleLogin(event) {
        this.toggleModal();
        alert("Username: " + this.username.value + " Password: " + this.password.value
            + " Remember: " + this.remember.checked);
        event.preventDefault();

    }

  . . .

  Save all the changes and do a Git commit with the message "Uncontrolled Form"

Conclusions
In this exercise we learnt to use an uncontrolled component approach to add a form to our React application.


Description Forms Controlled vs Uncontrolled components:
Normally, form elements in HTML maintain their own state within DOM and update it based on user input.
A Controlled component makes the React component itself control the form that it renders.
That is, it way of setting up forms in your React Application whereby your form information is directly tied into the state of your React component that is hosting the form instead of DOM.
So, any changes that you make to your form imports will be immediately reflected into the state of your React component.
The ContactComponent in our app is a controlled component.
Uncontrolled forms:
Ideally whenever we implement forms within out react application, we should implement them inside controlled components.
But there are many situations where we may not wish to go through all the expensive set up that we did for the control forms in the control components.
And also there may be situations where we may wish to just let the form information be handled by the DOM itself
As we realize any HTML form elements state is already tracked by the DOM.
So maybe in simple setup, we would be happy with letting the DOM track the form state, and then retrieve that directly from the form.
So how do we retrieve this information?
Now every, DOM form element has a ref associated with it, from which we can easily use that to extract their HTML form data into our application.
We need to tie in a function there to enable us to retrieve that information into our application.
Now this approach of using uncontrolled forms is a lot more easier in situations when we are mixing our React application code with non-React code.
So maybe we have a project that is already setup with some non-React part, and then we're adding in React components or React elements to that project to set up some parts of the project.
In that case, setting up uncontrolled forms where it interacts with the rest of your non-React code is more easier.

Exercise (Instructions): Introduction to Redux
Objectives and Outcomes
In this exercise you will learn to use Redux. You will install and configure Redux and use it within your React application.
At the end of this exercise you will be able to:

1.Install and configure Redux within your application
2.Configure your React application to make use of Redux

Installing and Configuring Redux
  As a first step you will install Redux and React-Redux into your application as follows:
  yarn add redux@3.7.2
  yarn add react-redux@5.0.7

  Next, create a folder named redux in the src folder and then add a file named reducer.js with the code below:
  import { DISHES } from '../shared/dishes';
  import { COMMENTS } from '../shared/comments';
  import { PROMOTIONS } from '../shared/promotions';
  import { LEADERS } from '../shared/leaders';

  export const initialState = {
      dishes: DISHES,
      comments: COMMENTS,
      promotions: PROMOTIONS,
      leaders: LEADERS
  };

  export const Reducer = (state = initialState, action) => {
      return state;
  };

  Then, add a file named configureStore.js in the redux folder and add the following code to it:
  import {createStore} from 'redux';
  import { Reducer, initialState } from './reducer'

  export const ConfigureStore = () => {
      const store = createStore(
          Reducer, // reducer
          initialState, // our initialState
      );

      return store;
  }

  Next, open App.js and update it as follows:
  . . .


  import { Provider } from 'react-redux';
  import { ConfigureStore } from './redux/configureStore';

  const store = ConfigureStore();


  . . .

      <Provider store={store}>
        <BrowserRouter>
          <div className="App">
            <Main />
          </div>
        </BrowserRouter>
      </Provider>

  . . .

  Finally, update MainComponent.js to connect it to Redux store and use it:
  . . .

  import { Switch, Route, Redirect, withRouter } from 'react-router-dom'
  import { connect } from 'react-redux';


  const mapStateToProps = state => {
    return {
      dishes: state.dishes,
      comments: state.comments,
      promotions: state.promotions,
      leaders: state.leaders
    }
  }

. . .

    const HomePage = () => {
      return(
          <Home
              dish={this.props.dishes.filter((dish) => dish.featured)[0]}
              promotion={this.props.promotions.filter((promo) => promo.featured)[0]}
              leader={this.props.leaders.filter((leader) => leader.featured)[0]}
          />
      );
    }

    const DishWithId = ({match}) => {
      return(
          <DishDetail dish={this.props.dishes.filter((dish) => dish.id === parseInt(match.params.dishId,10))[0]}
            comments={this.props.comments.filter((comment) => comment.dishId === parseInt(match.params.dishId,10))} />
      );
    };

      return (
        <div>
          <Header />
          <div>
            <Switch>
                <Route path='/home' component={HomePage} />
                <Route exact path='/aboutus' component={() => <About leaders={this.props.leaders} />} />} />
                <Route exact path='/menu' component={() => <Menu dishes={this.props.dishes} />} />
                <Route path='/menu/:dishId' component={DishWithId} />
                <Route exact path='/contactus' component={Contact} />} />
                <Redirect to="/home" />
            </Switch>
          </div>
          <Footer />
        </div>
      );
    }
  }

  export default withRouter(connect(mapStateToProps)(Main));

  Save all the changes and do a Git commit with the message "Intro. to Redux".

Conclusions
In this exercise you learnt to install and configure Redux and use it in your React application.

React Redux Forms:
The react-redux-form provides us with a lot of features that enable us to leverage redux for our form persistence and also form validation.
What exactly is React-Redux-Form?
It is a versatile, fast and intuitive library for creating complex and performant forms in React using Redux.
The React-Redux-Form itself persist the state of our form into a model in the redux store.
And React-Redux-Form also provides a collection of reducer creators and action creators for us that enables us to do all this work for us without writing much code.
Now that's where the React-Redux-Form takes care of all the grunt work behind persisting the form in the Redux store.
Why would you need that?
Say, for example, we are on a view and we're filling out a form and then we navigate out of the view.
Very often when we have standard react components, when we move out of a view, the state of the, whatever local state that you stored in that component will get destroyed.
And so when we return to the same view, if we had filled up a form, the form would remain unfilled.
Suppose we want to persist the state of the form even across page reloads or as we navigate in and out of a view,
then React-Redux-Form would be of use to us.
So, this is achieved by the form data being stored in the redux in a model.
And all the details of how this persistence is done is automatically taken care of by React-Redux-Form without us needing to do any reducer functions or the action creators on our behalf.
And also, React-Redux-Form brings in its own support for validation as we will see in one of the exercises that follows this lecture.
If we want to use React-Redux-Form purely for its form validation and not require the form data to be persistent in the redux store, instead if we want it to be persistent in the local state of the component, then we can simply use a local form that is also supported by React-Redux-Form to create forms.
This is suitable when we don't need persistence across component mounting/unmounting in our application. So, that's the advantage of using local forms.

Exercise (Instructions): React Redux Form
Objectives and Outcomes
In this exercise you will install react-redux-form and then convert the controlled form that we created earlier into a form supported by react-redux-form.
At the end of this exercise you will be able to:

1.Install and configure react-redux-form
2.Implement a controlled form using react-redux-form

1.Installing and Using react-redux-form
  We first install the react-redux-form into our project as follows:
  yarn add react-redux-form@1.16.8

  Then open ContactComponent.js and update the Feedback Form to use react-redux-form:
  . . .

  import { Breadcrumb, BreadcrumbItem,
              Button, Row, Col, Label } from 'reactstrap';
  import { Control, LocalForm, Errors } from 'react-redux-form';

  . . .


      handleSubmit(values) {
          console.log('Current State is: ' + JSON.stringify(values));
          alert('Current State is: ' + JSON.stringify(values));
          // event.preventDefault();
      }

  . . .

                        <LocalForm onSubmit={(values) => this.handleSubmit(values)}>
                            <Row className="form-group">
                                <Label htmlFor="firstname" md={2}>First Name</Label>
                                <Col md={10}>
                                    <Control.text model=".firstname" id="firstname" name="firstname"
                                        placeholder="First Name"
                                        className="form-control"
                                         />
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Label htmlFor="lastname" md={2}>Last Name</Label>
                                <Col md={10}>
                                    <Control.text model=".lastname" id="lastname" name="lastname"
                                        placeholder="Last Name"
                                        className="form-control"
                                         />
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Label htmlFor="telnum" md={2}>Contact Tel.</Label>
                                <Col md={10}>
                                    <Control.text model=".telnum" id="telnum" name="telnum"
                                        placeholder="Tel. Number"
                                        className="form-control"
                                         />
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Label htmlFor="email" md={2}>Email</Label>
                                <Col md={10}>
                                    <Control.text model=".email" id="email" name="email"
                                        placeholder="Email"
                                        className="form-control" />
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Col md={{size: 6, offset: 2}}>
                                    <div className="form-check">
                                        <Label check>
                                            <Control.checkbox model=".agree" name="agree"
                                                className="form-check-input"
                                                 /> {' '}
                                                <strong>May we contact you?</strong>
                                        </Label>
                                    </div>
                                </Col>
                                <Col md={{size: 3, offset: 1}}>
                                    <Control.select model=".contactType" name="contactType"
                                        className="form-control">
                                        <option>Tel.</option>
                                        <option>Email</option>
                                    </Control.select>
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Label htmlFor="message" md={2}>Your Feedback</Label>
                                <Col md={10}>
                                    <Control.textarea model=".message" id="message" name="message"
                                        rows="12"
                                        className="form-control" />
                                </Col>
                            </Row>
                            <Row className="form-group">
                                <Col md={{size:10, offset: 2}}>
                                    <Button type="submit" color="primary">
                                    Send Feedback
                                    </Button>
                                </Col>
                            </Row>
                        </LocalForm>

  . . .

  Save all the changes and do a Git commit with the message "React Redux Form".

Conclusions
In this exercise we installed and used the react-redux-form to design a controlled form.

Exercise (Instructions): React Redux Form Validation
Objectives and Outcomes
In this exercise we will explore simple form validation for react-redux-form.
At the end of this exercise you will be able to:

1.Configure and implement simple form validation for controlled forms designed using react-redux-form.

1.Implementing Simple Form Validation
  Open ContactComponent.js and update it as follows to implement form validation:
  . . .


  const required = (val) => val && val.length;
  const maxLength = (len) => (val) => !(val) || (val.length <= len);
  const minLength = (len) => (val) => val && (val.length >= len);
  const isNumber = (val) => !isNaN(Number(val));
  const validEmail = (val) => /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(val);

  . . .

                              <Row className="form-group">
                                  <Label htmlFor="firstname" md={2}>First Name</Label>
                                  <Col md={10}>
                                      <Control.text model=".firstname" id="firstname" name="firstname"
                                          placeholder="First Name"
                                          className="form-control"
                                          validators={{
                                              required, minLength: minLength(3), maxLength: maxLength(15)
                                          }}
                                          />
                                      <Errors
                                          className="text-danger"
                                          model=".firstname"
                                          show="touched"
                                          messages={{
                                              required: 'Required',
                                              minLength: 'Must be greater than 2 characters',
                                              maxLength: 'Must be 15 characters or less'
                                          }}
                                      />
                                  </Col>
                              </Row>
                              <Row className="form-group">
                                  <Label htmlFor="lastname" md={2}>Last Name</Label>
                                  <Col md={10}>
                                      <Control.text model=".lastname" id="lastname" name="lastname"
                                          placeholder="Last Name"
                                          className="form-control"
                                          validators={{
                                              required, minLength: minLength(3), maxLength: maxLength(15)
                                          }}
                                          />
                                      <Errors
                                          className="text-danger"
                                          model=".lastname"
                                          show="touched"
                                          messages={{
                                              required: 'Required',
                                              minLength: 'Must be greater than 2 characters',
                                              maxLength: 'Must be 15 characters or less'
                                          }}
                                      />
                                  </Col>
                              </Row>
                              <Row className="form-group">
                                  <Label htmlFor="telnum" md={2}>Contact Tel.</Label>
                                  <Col md={10}>
                                      <Control.text model=".telnum" id="telnum" name="telnum"
                                          placeholder="Tel. Number"
                                          className="form-control"
                                          validators={{
                                              required, minLength: minLength(3), maxLength: maxLength(15), isNumber
                                          }}
                                          />
                                      <Errors
                                          className="text-danger"
                                          model=".telnum"
                                          show="touched"
                                          messages={{
                                              required: 'Required',
                                              minLength: 'Must be greater than 2 numbers',
                                              maxLength: 'Must be 15 numbers or less',
                                              isNumber: 'Must be a number'
                                          }}
                                      />
                                  </Col>
                              </Row>
                              <Row className="form-group">
                                  <Label htmlFor="email" md={2}>Email</Label>
                                  <Col md={10}>
                                      <Control.text model=".email" id="email" name="email"
                                          placeholder="Email"
                                          className="form-control"
                                          validators={{
                                              required, validEmail
                                          }}
                                          />
                                      <Errors
                                          className="text-danger"
                                          model=".email"
                                          show="touched"
                                          messages={{
                                              required: 'Required',
                                              validEmail: 'Invalid Email Address'
                                          }}
                                      />
                                  </Col>
                              </Row>

  . . .

  Save all the changes and do a Git commit with the message "React Redux Form Validation"

Conclusions
In this exercise you learnt about implementing simple form validation using react-redux-form.


React Forms and Redux Assignment:
In this assignment you will update the DishdetailComponent.js to include a form and do the form validation in code.
At the end of this assignment, you should have completed the following tasks to update the page:

1. Added a new class component named CommentForm to DishdetailComponent.js.
2. Provide a form to enable users to submit their comments
3. Validate the information entered by the users in the form

Assignment Requirements:

Task 1
In this task you will add a new class component named CommentForm. You need to complete the following:
Add a new class component named CommentForm that will add a button to the view as shown in the image below.
When the button is clicked, it toggles a modal that will display the comment form.
The CommentForm component is used by the RenderComments function to display the button for toggling the modal.

Task 2
In this task you will construct the form for users to submit their comments as shown in the image below. You need to complete the following:
Set up the form as a local form using the react-redux-form with the three fields: author, rating and comment.
The rating field in the comment form is implemented using a select, the author is implemented using a text field, while the comment uses a textarea with six rows.

Task 3
In this task, you will enable form validation as shown in the images below. You need to complete the following:
The author field should at least be three characters long.
The author field should be less than or equal to 15 characters.
The user should be alerted by showing the invalid message displayed at the bottom of the field.

Exercise (Instructions): Combining Reducers
Objectives and Outcomes
In this exercise you will learn about how we can have separate reducers managing parts of the state,
and how they can be combined together to manage the whole state.
At the end of this exercise you will be able to:

1.Implement reducers that are responsible for only part of the state
2.Combine the reducers to manage the entire state

1.Splitting the Reducer
  In the redux folder, create a new file named dishes.js and add the following to it:
  import { DISHES } from '../shared/dishes';

  export const Dishes = (state = DISHES, action) => {
      switch (action.type) {
          default:
            return state;
        }
  };

  Then, create a file named comments.js and add the following to it:
  import { COMMENTS } from '../shared/comments';

  export const Comments = (state = COMMENTS, action) => {
      switch (action.type) {

          default:
            return state;
        }
  };

  Similarly, create a new file named promotions.js and add the following to it:
  import { PROMOTIONS } from '../shared/promotions';

  export const Promotions = (state = PROMOTIONS, action) => {
      switch (action.type) {
          default:
            return state;
        }
  };

  And finally, create a new file named leaders.js and add the following to it:
  import { LEADERS } from '../shared/leaders';

  export const Leaders = (state = LEADERS, action) => {
      switch (action.type) {
          default:
            return state;
        }
  };

  Now that we have split the management of state into different reducers that manage partial state, we need to combine them together. Open configureStore.js and update it as follows:
  import {createStore, combineReducers} from 'redux';
  import { Dishes } from './dishes';
  import { Comments } from './comments';
  import { Promotions } from './promotions';
  import { Leaders } from './leaders';

  export const ConfigureStore = () => {
      const store = createStore(
          combineReducers({
              dishes: Dishes,
              comments: Comments,
              promotions: Promotions,
              leaders: Leaders
          })
      );

      return store;
  }

  Now we can safely delete the reducer.js file from the project.
  Save all the changes and do a Git commit with the message "Combining Reducers".

Conclusions
In this exercise we have learnt to split the reducer into multiple reducers that manage partial state, and then combine them together.

Exercise (Instructions): Redux Actions:
In this exercise, we're going to create our first action,
where by the comment that you submit will be added into the list of comments for our application.
So, we will modify by introducing a new action for our application, which we'll take the comment and then add it into the comments field.
So, this requires us to change the state of our application.
So, we need an action that enables us to change the state of our application in the Redux store.
So, when we submit the comment, we'll see that the submission of the comment will trigger action to be sent to your redux store,
and then this action will result in the comment being added into the comments part of the state of our redux store,
and then when the changes, then that will result in the store emitting a change,
and that will result in our main component going and getting the updated state from the redux store,
and then the main component passes the new state to all the chilled components,
and then the RenderComments component realizes that the comments part has changed, so it will have to be rendered.
So, react takes care of re rendering that with new the comment added into the list there.

Objectives and Outcomes
In this exercise we will learn to define various Redux actions
and implement the action creators to dispatch the actions to the Redux store.
At the end of this exercise you will be able to:
1.Define Redux actions and implement the action creators
2.Dispatch actions from the action creators to update the system state in the Redux store

1.Creating Actions
  In the redux folder create a new file named ActionTypes.js and add the following to it:
  export const ADD_COMMENT = 'ADD_COMMENT';

  Then, create a file named ActionCreators.js and add the following to it:
  import * as ActionTypes from './ActionTypes';

  export const addComment = (dishId, rating, author, comment) => ({
      type: ActionTypes.ADD_COMMENT,
      payload: {
          dishId: dishId,
          rating: rating,
          author: author,
          comment: comment
      }
  });

  Next, update comments.js to initiate action when the action is dispatched by the ActionCreator as follows:
  import { COMMENTS } from '../shared/comments';
  import * as ActionTypes from './ActionTypes';

  export const Comments = (state = COMMENTS, action) => {
      switch (action.type) {
          case ActionTypes.ADD_COMMENT:
              var comment = action.payload;
              comment.id = state.length;
              comment.date = new Date().toISOString();
              console.log("Comment: ", comment);
              return state.concat(comment);

          default:
            return state;
        }
  };

  Now update MainComponent.js to make the action available for use within the DishdetailComponent as follows:
  . . .

  import { addComment } from '../redux/ActionCreators';

  . . .

    const mapDispatchToProps = dispatch => ({

      addComment: (dishId, rating, author, comment) => dispatch(addComment(dishId, rating, author, comment))

    });

  . . .

        <DishDetail dish={this.props.dishes.filter((dish) => dish.id === parseInt(match.params.dishId,10))[0]}
          comments={this.props.comments.filter((comment) => comment.dishId === parseInt(match.params.dishId,10))}
          addComment={this.props.addComment}
        />

  . . .

  export default withRouter(connect(mapStateToProps, mapDispatchToProps)(Main));

  Finally, update DishdetailComponent.js as follows to initiate the action upon the user submitting the comment form:
  . . .

  function RenderComments({comments, addComment, dishId}) {



  . . .

      <CommentForm dishId={dishId} addComment={addComment} />


  . . .

        this.props.addComment(this.props.dishId, values.rating, values.author, values.comment);



  . . .

      <RenderComments comments={props.comments}
        addComment={props.addComment}
        dishId={props.dish.id}
      />

  . . .

  Save all the changes and do a Git commit with the message "Redux Actions"

Conclusions
In this exercise we have learnt to create and dispatch actions to update the system state in the Redux store.

Exercise (Instructions): Redux Thunk
Objectives and Outcomes
Redux Thunk middleware allows you to write action creators that return a function instead of an action.
In this exercise you will see the use of redux thunk to return a function.
At the end of this exercise you will be able to:
1. Use Redux Thunk middleware to return a function instead of an action
2. Use a logger to print a log of actions initiated on the Redux store.

1.Installing Redux Thunk and Logger
  Install Redux Thunk and Logger as shown below:
  yarn add redux-thunk@2.2.0
  yarn add redux-logger@3.0.6

  Then open configureStore.js and update it to use the Thunk and Logger as follows:
  import {createStore, combineReducers, applyMiddleware } from 'redux';

  . . .

  import thunk from 'redux-thunk';
  import logger from 'redux-logger';

  . . .

        combineReducers({
            dishes: Dishes,
            comments: Comments,
            promotions: Promotions,
            leaders: Leaders
        }),
        applyMiddleware(thunk, logger)

  . . .

  Next, open ActionTypes.js and add new action types as follows:
  . . .

  export const DISHES_LOADING = 'DISHES_LOADING';
  export const DISHES_FAILED = 'DISHES_FAILED';
  export const ADD_DISHES = 'ADD_DISHES';

  Then open ActionCreators.js and add new actions:
  . . .

  import { DISHES } from '../shared/dishes';

  . . .


  export const fetchDishes = () => (dispatch) => {

      dispatch(dishesLoading(true));

      setTimeout(() => {
          dispatch(addDishes(DISHES));
      }, 2000);
  }

  export const dishesLoading = () => ({
      type: ActionTypes.DISHES_LOADING
  });

  export const dishesFailed = (errmess) => ({
      type: ActionTypes.DISHES_FAILED,
      payload: errmess
  });

  export const addDishes = (dishes) => ({
      type: ActionTypes.ADD_DISHES,
      payload: dishes
  });

  Next, open dishes.js and add the code to respond to actions as follows:
  import * as ActionTypes from './ActionTypes';

  export const Dishes = (state = { isLoading: true,
      errMess: null,
      dishes:[]}, action) => {
      switch (action.type) {
          case ActionTypes.ADD_DISHES:
              return {...state, isLoading: false, errMess: null, dishes: action.payload};

          case ActionTypes.DISHES_LOADING:
              return {...state, isLoading: true, errMess: null, dishes: []}

          case ActionTypes.DISHES_FAILED:
              return {...state, isLoading: false, errMess: action.payload};

          default:
              return state;
      }
  };

  Add a new component named LoadingComponent.js to display a loading message as follows:
  import React from 'react';

  export const Loading = () => {
      return(
          <div className="col-12">
              <span className="fa fa-spinner fa-pulse fa-3x fa-fw text-primary"></span>
              <p>Loading . . .</p>
          </div>
      );
  };

  Now we will update the remaining components to use the actions. First, open MainComponent.js and update it as follows:
  . . .

  import { addComment, fetchDishes } from '../redux/ActionCreators';

  . . .

  fetchDishes: () => { dispatch(fetchDishes())}

  . . .

    componentDidMount() {
    this.props.fetchDishes();
  }

  . . .

    const HomePage = () => {
      return(
          <Home
              dish={this.props.dishes.dishes.filter((dish) => dish.featured)[0]}
              dishesLoading={this.props.dishes.isLoading}
              dishesErrMess={this.props.dishes.errMess}
              promotion={this.props.promotions.filter((promo) => promo.featured)[0]}
              leader={this.props.leaders.filter((leader) => leader.featured)[0]}
          />
      );
    }

    const DishWithId = ({match}) => {
      return(
          <DishDetail dish={this.props.dishes.dishes.filter((dish) => dish.id === parseInt(match.params.dishId,10))[0]}
            isLoading={this.props.dishes.isLoading}
            errMess={this.props.dishes.errMess}
            comments={this.props.comments.filter((comment) => comment.dishId === parseInt(match.params.dishId,10))}
            addComment={this.props.addComment}
          />
      );
    };

  . . .

  Open DishdetailComponent.js and update it as follows:
  . . .

  import { Loading } from './LoadingComponent';

  . . .


        if (props.isLoading) {
            return(
                <div className="container">
                    <div className="row">
                        <Loading />
                    </div>
                </div>
            );
        }
        else if (props.errMess) {
            return(
                <div className="container">
                    <div className="row">
                        <h4>{props.errMess}</h4>
                    </div>
                </div>
            );
        }
        else if (props.dish != null)

  . . .

  Open HomeComponent.js and update it as follows:
  . . .

  import { Loading } from './LoadingComponent';

  . . .


  function RenderCard({item, isLoading, errMess}) {

      if (isLoading) {
          return(
                  <Loading />
          );
      }
      else if (errMess) {
          return(
                  <h4>{errMess}</h4>
          );
      }
      else
          return(
              <Card>
                  <CardImg src={item.image} alt={item.name} />
                  <CardBody>
                  <CardTitle>{item.name}</CardTitle>
                  {item.designation ? <CardSubtitle>{item.designation}</CardSubtitle> : null }
                  <CardText>{item.description}</CardText>
                  </CardBody>
              </Card>
          );

  }

  . . .

                    <RenderCard item={props.dish} isLoading={props.dishesLoading} errMess={props.dishesErrMess}  />

  . . .

  Finally, update MenuComponent.js as follows:
  . . .

  import { Loading } from './LoadingComponent';

  . . .

        const menu = props.dishes.dishes.map((dish) => {

  . . .


        if (props.dishes.isLoading) {
            return(
                <div className="container">
                    <div className="row">
                        <Loading />
                    </div>
                </div>
            );
        }
        else if (props.dishes.errMess) {
            return(
                <div className="container">
                    <div className="row">
                        <div className="col-12">
                            <h4>{props.dishes.errMess}</h4>
                        </div>
                    </div>
                </div>
            );
        }
        else

  . . .

  Save all the changes and do a Git commit with the message "Redux Thunk".

Conclusions
In this exercise we saw the use of Redux Thunk and the Logger.

Redux explanation:
The Redux Middleware provides the capability to run a code after an action is dispatched, before it reaches the reducer.
Now once an action reaches the reducer, the reducer will act on the action and make changes to the state of the store.
So before that point, we can intercept action and effect some changes before the action reaches the reducer.
So this is a place which enables third party extensions to be injected into your Redux application.
So for example, if you want to log all the actions that have been dispatched,
that is a good point for you to first capture the action,
log what the action is and then let it move on to the reducer,
and then you can then log the state of the application after the action is effected.
Similarly, if we want to allow asynchronous API calls, so for example,
we dispatch an action but the action would initially require access to a server from where we fetch the data and then send the data into your Redux store.
Then that is also a good place to interject a middleware in order to intercept the action and then carry out basing API call and then let the action proceed forward into the store.
Middleware forms a pipeline that wraps around the dispatch,
then it can make any changes there and it can pass that action forward.
If it requires, it can restart the dispatch pipeline as it is required.
And not only that, at that point, you even get access to the store state.
If you want to look at the store state and then make any modifications before you let the action pass through.
So here are the few examples of things that you can do with the middleware that you interject into your Redux application.
So the middleware can be typically used for:
1. Inspecting the actions and the state.
2. Modify actions
3. Dispatch other actions and then wait for the results from those actions before you allow this particular action to take place.
4. Stop an action from reaching the reducers etc
The applyMiddleware() function of redux sets up amiddleware pipeline and returns a store enhancer that is passed to createStore().
What is a Thunk in programming?
Thunk is a subroutine that is used to inject an additional calculation into another subroutine.
So this is a way to delay a calculation until its result is needed
and also allows you to insert operations at the beginning or the end of another subroutine.
A Redux Thunk is a middleware that allows you to write an action creator that will return a function instead of an action object.
Then that function can be executed and within that function, you can design it in such a way that you can use it to :
1. delay the dispatch of an action until a certain condition is met
   eg if you want to do a synchronous API call to a server, you may use a thunk in order to generate a synchronous API call,
   and then when the server replies and you receive the reply, at that point you can let the action proceed forward and then make modifications to the store.
2. Dispatch only if certain condition is met.

The inner function that you define inside a thunk gets access to both the dispatch() as well as getState()from store.
What does this permit you to do? Because you have access to get state, you can examine the state and then see if this action fits and can be allowed with the current state. So that would allow you to even modify the action, and also you'll get access to dispatch.
So for example, you can stop the current action, do something else, come back and then dispatch the action into the reducers.
It also allows you to do complex synchronous logic.
1. Multiple dispatches
2. Conditionl dispatches
3. Simple async logic
So for example with one action, you can actually end up dispatching multiple dispatches and may cause multiple effects if that is what you intend to do.
You can even do conditional dispatch depending on the condition.
So for example, if you issue an synchronous API call to the server, and if the server returns the result successfully,
then you can dispatch one action to the reducer.
If the API call returns a failure, then you can dispatch a different action to the reducer to make changes to the state accordingly.

If you want a more powerful way of doing things like complex async logics, then we have access to another library called a Redux Saga.
A Redux Saga allows you to use ES6 generators to generate pausable functions.
And also, the saga allows ongoing background thread like operations or processing behavior if you so require.
So complex react applications that require that kind of behavior would definitely benefit by using a Redux Saga in the place of a Redux Thunk.

Exercise (Instructions): Redux Thunk:
Objectives:
Use Redux Thunk middleware to return a function instead of an action
Use a logger middleware to print a log of actions initiated on the Redux store.i.e log all the changes that we caused to the Redux store into our console.

1. Install Redux Thunk and Logger.
  yarn add redux-thunk@2.2.0
  yarn add redux-logger@3.0.6
2. Then open configureStore.js and update it to use the Thunk and Logger
3. Next, open ActionTypes.js and add new action types
4. Then open ActionCreators.js and add new actions:
5. Next, open dishes.js and add the code to respond to actions.
6. Add a new component named LoadingComponent.js to display a loading message:
7. Now we will update the remaining components to use the actions. First, open MainComponent.js and update it
8. Open DishdetailComponent.js and update it.
9. Open HomeComponent.js and update it
10.Finally, update MenuComponent.js

Exercise (Instructions): React-Redux-Form Revisited
Objectives and Outcomes
In this exercise we will explore the interaction between react-redux-form and the Redux store.
We will see how to map the form into the store so that the state of the form will be persisted in the store.
At the end of this exercise you will be able to:
1.Use react-redux-form to interact with Redux store and store the state of the form in the store.

1.Updating the Feedback Form
  Add a new file named forms.js in the redux folder and add the following to it:
  export const InitialFeedback = {
    firstname: '',
    lastname: '',
    telnum: '',
    email: '',
    agree: false,
    contactType: 'Tel.',
    message: ''
  };

  Then, open configureStore.js and update it to add the form to the reducers:
  . . .

  import { createForms } from 'react-redux-form';

  . . .

  import { InitialFeedback } from './forms';

  . . .

        combineReducers({
            dishes: Dishes,
            comments: Comments,
            promotions: Promotions,
            leaders: Leaders,
            ...createForms({
                feedback: InitialFeedback
            })
        }),

  . . .

  Next, open MainComponent.js and update it as follows:
  . . .

  import { actions } from 'react-redux-form';

  . . .

  resetFeedbackForm: () => { dispatch(actions.reset('feedback'))}

  . . .

              <Route exact path='/contactus' component={() => <Contact resetFeedbackForm={this.props.resetFeedbackForm} />} />

  . . .

  Open CommentComponent.js and update it as follows:
  . . .

  import { Control, Form, Errors, actions } from 'react-redux-form';

  . . .

    handleSubmit(values) {
        console.log('Current State is: ' + JSON.stringify(values));
        alert('Current State is: ' + JSON.stringify(values));
        this.props.resetFeedbackForm();
        // event.preventDefault();
    }

  . . .

                        <Form model="feedback" onSubmit={(values) => this.handleSubmit(values)}>

                          . . .


                        </Form>

  . . .

  Save all the changes and do a Git commit with the message "React Redux Forms Revisited".

Conclusions
In this exercise we have seen how to use react-redux-form together with Redux to persist form state.

Description:
In the React-Redux-Form lesson in the previous module, we learned how to use the React-Redux-Form Package
and we saw how we can make use of the local form to create a React-Redux-Form in our application,
and then we saw that the state is mapped into the local state of the component.
Now, if we want to make use of the full power of the React-Redux-Form whereby the form state is persisted in the Redux store instead of in the components state,
then we need to update our form to make use of the regular form rather than the local form from the React-Redux-Form.
So in this exercise, we updated our application in the contactComponent to enable us to make use of the full power of React-Redux-Form.

Exercise (Instructions): Setting up a Server using json-server:

Objectives and Outcomes
The Node module, json-server, provides a very simple way to set up a web server that supports a full-fledged REST API server.
It can also serve up static web content from a folder.
This lesson we will leverage these two features to provide the back-end for our React application.
In this exercise, we will configure and start a server using json-server to enable serving our application data to our React application.
At the end of this exercise, we will be able to:

Configure and start a simple server using the json-server module
Configure our server to serve up static web content stored in a folder named public.

1.Installing json-server:
  json-server is a node module, and hence can be installed globally by typing the following at the command prompt:

  npm install json-server -g
  If you are using OSX or Linux, use sudo at the front of the command. This will install json-server that can be started from the command line from any folder on your computer.

2.Configuring the Server:
  At any convenient location on your computer, create a new folder named json-server, and move to this folder.
  Download the db.json file provided above to this folder.
  Move to this folder in your terminal window, and type the following at the command prompt to start the server:

  json-server --watch db.json -p 3001 -d 2000

  The reason for using this watch flag is that?
  This json-server will keep a watch on the db.jason file and anytime the db.jason file is modified.
  It'll reload the db.jason file and start serving up that modified data from the server.
  In addition, we can also give it -d flag, with a value, say for example, 2000.
  Which means that when the server receives a request, it will serve the data back to the requester after a two second delay.
  Now this would be used to simulate delay in accessing a server over the Internet.
  And another flag, -p 3001, though specify that the json-server should run at both number 3001.
  The default port number is 3000 for the json-server.
  But since our application is running at port number 3000, so we chose to run the json-server at port number 3001.

  This should start up a server at port number 3001 on your machine.

  The data from this server can be accessed by typing the following addresses into your browser address bar:
  http://localhost:3001/dishes
  http://localhost:3001/promotions
  http://localhost:3001/leaders
  http://localhost:3001/feedback

  Type these addresses into the browser address and see the JSON data being served up by the server.
  This data is obtained from the db.json file.
  The json-server also provides a static web server.
  Any resources that you put in a folder named public in the json-server folder above, will be served by the server at the following address:

  http://localhost:3001/

  Shut down the server by typing ctrl-C in the terminal window.

3.Serving up the Images:
  Create a public folder in your json-server folder.
  Download the images.zip file that we provide above, unzip it and move the images folder containing the images to the public folder.
  Restart the json-server as we did before.
  Now your server will serve up the images for our React app.
  You can view these images by typing the following into your browser address bar:

  http://localhost:3001/images/<image name>.png

Conclusions
In this exercise, you learnt how to configure and start a simple server using the json-server node module.
You also learnt how the server can serve up static web content.

Exercise (Instructions): Fetch from Server:

Objectives and Outcomes
In this exercise you will incorporate Fetch into our React app and then use it to communicate with the REST API server.
At the end of this exercise you will be able to:
1. Incorporate Fetch into your React app
2. Use Fetch to communicate with the REST API server

1. Fetch
  As a first step, let us install Fetch into our project:
  yarn add cross-fetch@2.1.0

  Now that we have installed Fetch, let us configure our application to connect to the server.
  First, create a file named baseUrl.js in the shared folder and add the following to it:
  export const baseUrl = 'http://localhost:3001/';
  This is really beneficial,let's say if my server is running at a different location, I would have a single place where I need to update the server address and don't need to go to change the rest of my application.

  Make sure that the json-server is running and serving up the data as illustrated in the previous exercise
  Next, open ActionTypes.js and update it as follows:

  export const ADD_COMMENTS = 'ADD_COMMENTS';
  export const COMMENTS_FAILED = 'COMMENTS_FAILED';
  export const PROMOS_LOADING = 'PROMOS_LOADING';
  export const ADD_PROMOS = 'ADD_PROMOS';
  export const PROMOS_FAILED = 'PROMOS_FAILED';

  Then, open ActionCreators.js and update it as follows:
  . . .

  import { baseUrl } from '../shared/baseUrl';

  . . .

    return fetch(baseUrl + 'dishes')
    .then(response => response.json())
    .then(dishes => dispatch(addDishes(dishes)));

  . . .


  export const fetchComments = () => (dispatch) => {
      return fetch(baseUrl + 'comments')
      .then(response => response.json())
      .then(comments => dispatch(addComments(comments)));
  };

  export const commentsFailed = (errmess) => ({
      type: ActionTypes.COMMENTS_FAILED,
      payload: errmess
  });

  export const addComments = (comments) => ({
      type: ActionTypes.ADD_COMMENTS,
      payload: comments
  });

  export const fetchPromos = () => (dispatch) => {

      dispatch(promosLoading());

      return fetch(baseUrl + 'promotions')
      .then(response => response.json())
      .then(promos => dispatch(addPromos(promos)));
  }

  export const promosLoading = () => ({
      type: ActionTypes.PROMOS_LOADING
  });

  export const promosFailed = (errmess) => ({
      type: ActionTypes.PROMOS_FAILED,
      payload: errmess
  });

  export const addPromos = (promos) => ({
      type: ActionTypes.ADD_PROMOS,
      payload: promos
  });

  Next, open comments.js and update it as follows:
  import * as ActionTypes from './ActionTypes';

  export const Comments = (state = { errMess: null, comments:[]}, action) => {
    switch (action.type) {
      case ActionTypes.ADD_COMMENTS:
        return {...state, errMess: null, comments: action.payload};

      case ActionTypes.COMMENTS_FAILED:
        return {...state, errMess: action.payload};

      case ActionTypes.ADD_COMMENT:
          var comment = action.payload;
          comment.id = state.comments.length;
          comment.date = new Date().toISOString();
          return { ...state, comments: state.comments.concat(comment)};

      default:
        return state;
    }
  };

  Similarly, open promotions.js and update it as follows:
  import * as ActionTypes from './ActionTypes';

  export const Promotions = (state  = { isLoading: true,
                                          errMess: null,
                                          promotions:[]}, action) => {
      switch (action.type) {
          case ActionTypes.ADD_PROMOS:
          return {...state, isLoading: false, errMess: null, promotions: action.payload};

          case ActionTypes.PROMOS_LOADING:
              return {...state, isLoading: true, errMess: null, promotions: []}

          case ActionTypes.PROMOS_FAILED:
              return {...state, isLoading: false, errMess: action.payload};

          default:
            return state;
        }
  };
  Now that the Redux actions are all updated, it's time to update the components.
  Open MainComponent.js and update it as follows:
  . . .

  import { addComment, fetchDishes, fetchComments, fetchPromos } from '../redux/ActionCreators';

  . . .


  const mapDispatchToProps = dispatch => ({
    addComment: (dishId, rating, author, comment) => dispatch(addComment(dishId, rating, author, comment)),
    fetchDishes: () => { dispatch(fetchDishes())},
    resetFeedbackForm: () => { dispatch(actions.reset('feedback'))},
    fetchComments: () => dispatch(fetchComments()),
    fetchPromos: () => dispatch(fetchPromos())
  });

  . . .

    componentDidMount() {
    this.props.fetchDishes();
    this.props.fetchComments();
    this.props.fetchPromos();
  }

  . . .

            <Home
              dish={this.props.dishes.dishes.filter((dish) => dish.featured)[0]}
              dishesLoading={this.props.dishes.isLoading}
              dishErrMess={this.props.dishes.errMess}
              promotion={this.props.promotions.promotions.filter((promo) => promo.featured)[0]}
              promoLoading={this.props.promotions.isLoading}
              promoErrMess={this.props.promotions.errMess}
              leader={this.props.leaders.filter((leader) => leader.featured)[0]}
            />

  . . .

          <DishDetail dish={this.props.dishes.dishes.filter((dish) => dish.id === parseInt(match.params.dishId,10))[0]}
            isLoading={this.props.dishes.isLoading}
            errMess={this.props.dishes.errMess}
            comments={this.props.comments.comments.filter((comment) => comment.dishId === parseInt(match.params.dishId,10))}
            commentsErrMess={this.props.comments.errMess}
            addComment={this.props.addComment}
          />

  . . .

  Then, open MenuComponent.js and update it as follows:
  . . .

  import { baseUrl } from '../shared/baseUrl';

  . . .

                    <CardImg width="100%" src={baseUrl + dish.image} alt={dish.name} />

  . . .

  Then, open HomeComponent.js and update it as follows:
  . . .

  import { baseUrl } from '../shared/baseUrl';

  . . .

                <CardImg src={baseUrl + item.image} alt={item.name} />

  . . .

                    <RenderCard item={props.promotion} isLoading={props.promoLoading} errMess={props.promoErrMess} />

  . . .

  Then, open DishdetailComponent.js and update it as follows:
  . . .

  import { baseUrl } from '../shared/baseUrl';

  . . .

                <CardImg top src={baseUrl + dish.image} alt={dish.name} />

  . . .

  Save all the changes and do a Git commit with the message "Fetch from Server".

Conclusions
In this exercise you have learnt to install Fetch and use it communicate with the server.

All the images required for the dishes, the promotions and the leaders, will be now also fetched from the server site.
So the only images that we will use from locally is the logo that obviously is not going to keep changing all the time.
So that would be, the only local image that we will use from the assets folder in the public folder.
Rest of the images will be loaded from server.

Exercise (Instructions): Fetch Handling Errors:

Objectives and Outcomes
In this exercise you will learn how to handle errors encountered while communicating with the server.
At the end of this exercise you will be able to:
1.Configure your app to appropriately handle errors encountered while communicating with the server

Handling Errors
  Open ActionCreators.js and update it as follows:
  . . .

  export const fetchDishes = () => (dispatch) => {

      dispatch(dishesLoading(true));

      return fetch(baseUrl + 'dishes')
      .then(response => {
          if (response.ok) {
            return response;
          } else {
            var error = new Error('Error ' + response.status + ': ' + response.statusText);
            error.response = response;
            throw error;
          }
        },
        error => {
              var errmess = new Error(error.message);
              throw errmess;
        })
      .then(response => response.json())
      .then(dishes => dispatch(addDishes(dishes)))
      .catch(error => dispatch(dishesFailed(error.message)));
  }

  . . .

  export const fetchComments = () => (dispatch) => {
      return fetch(baseUrl + 'comments')
      .then(response => {
          if (response.ok) {
            return response;
          } else {
            var error = new Error('Error ' + response.status + ': ' + response.statusText);
            error.response = response;
            throw error;
          }
        },
        error => {
              var errmess = new Error(error.message);
              throw errmess;
        })
      .then(response => response.json())
      .then(comments => dispatch(addComments(comments)))
      .catch(error => dispatch(commentsFailed(error.message)));
  };

  . . .

  export const fetchPromos = () => (dispatch) => {

      dispatch(promosLoading());

      return fetch(baseUrl + 'promotions')
      .then(response => {
          if (response.ok) {
            return response;
          } else {
            var error = new Error('Error ' + response.status + ': ' + response.statusText);
            error.response = response;
            throw error;
          }
        },
        error => {
              var errmess = new Error(error.message);
              throw errmess;
        })
      .then(response => response.json())
      .then(promos => dispatch(addPromos(promos)))
      .catch(error => dispatch(promosFailed(error.message)));
  }

  . . .

  Save all the changes and do a Git commit with the message "Fetch Handling Errors".

Conclusions
In this exercise you learnt how to configure your app to handle errors in communicating with the server.




Exercise (Instructions): Fetch Post Comment:

Objectives and Outcomes:

In this exercise we will learn how to configure Fetch to be able to post data to the server.
At the end of this exercise we will be able to:
1.Configure Fetch to post data (comments) to the server
2.Receive and process the response to the POST operation on the server.

The modification of the data on the server site is in turn when Fetched by and then pushed into our Redux store,
so that the update is reflected into our Redux store and thereafter, reflected into our view, when the Redux store gets updated.

1. Posting a Comment:
  Open ActionCreators.js and update it as follows:
  . . .

  export const addComment = (comment) => ({
      type: ActionTypes.ADD_COMMENT,
      payload: comment
  });

  export const postComment = (dishId, rating, author, comment) => (dispatch) => {

      const newComment = {
          dishId: dishId,
          rating: rating,
          author: author,
          comment: comment
      };
      newComment.date = new Date().toISOString();

      return fetch(baseUrl + 'comments', {
          method: "POST",
          body: JSON.stringify(newComment),
          headers: {
            "Content-Type": "application/json"
          },
          credentials: "same-origin"
      })
      .then(response => {
          if (response.ok) {
            return response;
          } else {
            var error = new Error('Error ' + response.status + ': ' + response.statusText);
            error.response = response;
            throw error;
          }
        },
        error => {
              throw error;
        })
      .then(response => response.json())
      .then(response => dispatch(addComment(response)))
      .catch(error =>  { console.log('post comments', error.message); alert('Your comment could not be posted\nError: '+error.message); });
  };

  . . .

  When we receive the comments from the server, the comment ID is automatically created by the server, so that'll be all automatically included there.
  So, we can remove this from the addComment, and similarly we can remove date as well, as we've already put that into place in the postComment.
  Then, this will take care of adding the comment into the redux store that we have.

  Open comment.js and remove the following two lines from it:
  . . .

       comment.id = state.comments.length;
       comment.date = new Date().toISOString();

  . . .

  So when we post a comment, we will first send the comment over to the server,
  and if the comment is successfully added on the server site and the server sends back a success of the posting of the comment,
  only then we will add it to the redux store.
  So, that way, we ensure that the comment posted by the user is actually reflected by changing the data on the server site before even adding it to that redux store.

  Open MainComponent.js and update it as follows:
  . . .

  import { postComment, fetchDishes, fetchComments, fetchPromos } from '../redux/ActionCreators';

  . . .

  postComment: (dishId, rating, author, comment) => dispatch(postComment(dishId, rating, author, comment))

  . . .

            postComment={this.props.postComment}

  . . .

  Finally, open DishdetailComponent.js and update it as follows:
  . . .

    function RenderComments({comments, postComment, dishId}) {

  . . .

                    <CommentForm dishId={dishId} postComment={postComment} />

  . . .

            this.props.postComment(this.props.dishId, values.rating, values.author, values.comment);

  . . .

                            postComment={props.postComment}

  . . .

  Save all the changes and do a Git commit with the message "Fetch Post Comment".

Conclusions
In this exercise you learnt to use Fetch to post data to the server.


React Animations:
There are several react animation libraries available, we will use  React-transition-group and React-animation-components.
The React-transition-group supports React animations through a set of CSS transitions that we can express using CSS classes.
Now, the React-transition-group used to be part of React in some of the very old versions of React, but there after has been separated out into its own NPM module called as React-transition-group.
So, now if you want to use it in your React application unit, explicitly install that and then make use of it in your application.
So, how does React-transition-group work?
The React-transition-group provides a set of components that enable you to manage components tips including mounting and unmounting.
So, they help to recognize when components are getting mounted and unmounted, and then they are designed specifically with animation in mind.
The components supported by the React-transition-group include a transition, a CSS transition, and a TransitionGroup, each meant for a specific purpose.
The transition is a generic transition and it lets you describe a transition from one component state to another component state over time.
Now, when you define component state, the transition component has four states that it goes through: the entering, the entered, the exiting and exited state.
So, whatever you put inside the transition component, you will apply the corresponding transitions when the enclosing children are being rendered, or mounted, and then unmounted.
So on that point, the transitions are applied.
So, this is used for animating the mounting and unmounting of a component, or the children that you enclose inside your transition component.
Now, here, the transition when you apply, uses a in prop which is used to toggle the transition state.
So, when the in prop goes from false to true, then you begin the sequence of state transitions from entering to the entered state.
Similarly, when you turn the in prop from true to false, then you are triggering the exiting state first and then on the exited state.
Now, you can specify a time out period for the time the transition dwells in the entering state before it enters the entered state.
So, once it is in the entered state, the transition is complete and then your component is tably shown, and when you are unmounting the component,
then it will also trigger the exiting state and then the exited state in that sequence.
So, you can specify the time out for it.
he CSS transition is something that you apply together with the transition.
The CSS transition applies a pair of CSS classes during the appear, enter, and exit stages of that transition.
Now, this also uses the in prop to decide which transition class to apply.
As an example, if you are applying the CSS transition to list items in a list, you would specify something like this.
<CSSTransition key={this.props.location.key} classNames="page" timeout={300}>
Should define .page-enter, .page-enter-active, .page-exit, .page-exit-active CSS classes within .css file.
If you're applying it to a specific item, not in a list, but a generic React element,
then you will say CSS transition, and then you have explicitly specified the in prop for the CSS transition,
and the in prop, you'll specify some value to it and when the value turns to true,
then you go from the entering to the entire state and then similarly, from the exiting to the exit state when the in prop goes from true to false.
So, for example, in the above example, we give a classNames as page. What this means is that, it will take four CSS classes which you will define in your CSS5.
The four classes would be page enter, page interactive, page exit, and page exit active.
Now, the page enter will be applied when you go into the entering state,
and then when you reach the entered state, the page enter-active will be applied,
and the page exit and exit-active as you would expect.
These CSS classes have to be specified, and within those CSS classes, you'll specify what kind of transition you want to cause.
You can change the opacity, you can do the transformation, so x and y transformation on your elements and so on can be applied.
The transition group is the component that the React-transition-group supports.
The transition group manages a set of transitions that you apply to a list.
So, if you are applying to a list, then you know that the list items may come in and go and so on.
So, for example, if you have a long list and then you add a new item to the list and you wanted to animate the entering of the new item into that list,
then the management of that, by using the transition class, that if you enclose the entire list in a transition group and then apply the transition to each list item,
then the "in" property of the transition and the returning of the in prop to true and false will be controlled by the transition group.
So, it automatically toggles the in prop for the components that are enclosed inside it.
So, if you apply to a list each list item, the in prop will be toggled as required.
So, if you add a new item into the list, let's say, for example, your data changed and a new item just got added into the list, the new item will animate itself into the list in the view by using the TransitionGroup.
We will use TransitionGroup for transiting between the various views when I navigate using my React cloud or so from a single page application.
The sliding in of the views is exactly caused by the TransitionGroup and the CSS transition.
React-animation-components is yet another package that supports animations.
t supports a set of react components.
React animation components are themselves implemented using React-transition-group, and so they have packaged these into a set of easily usable components that apply certain properties.
 So, these provide drop in animation features for your application and they make use of the GPU for accelerating these animations.
Now, the animation components that are supported by the React animation components include Fade, Transform and FadeTransform.
So, you can apply the fade component to do a fade on a React element, fade in or out.
You can do transform to transform the component x and y transforms on the component or the size and so on can be controlled by using the transform component,
and fade transform allows you to do both fade and transform together at the same time.
Now, similarly, for a list item for example, you have wrapper components called Stagger, Random and Loop.
If you apply Stagger to a list of items, the items will stagger into the list, so when the list is being laid out on the screen, the items will be laid out staggered on the screen.
The Random will randomly add delays when you're rendering items in a list and that's it.
The Loop will essentially loop through and perform the animations continuously.
So, for example, if you apply a loop on inside that you apply a fade animation component, the item, the React element that you enclose inside will be fading in and out, and in and out continuously.

Exercise (Instructions): React Animations:
Objectives and Outcomes
In this exercise you will learn to implement animations in your React app using react-transition-group.
At the end of this exercise you will be able to:

1.Configure your app to use react-transition-group for animations
2.Implement simple animation using the react-transition-group

1.Install react-transition-group in your React project:
  yarn add react-transition-group@2.3.0
2.Configure CSS classes for use in animation.
  Open App.css and add following classes:
  . . .

  .page-enter {
      opacity: 0.01;
      transform: translateX(-100%);
  }

  .page-enter-active {
      opacity: 1;
      transform: translateX(0%);
      transition: all 300ms ease-in;
  }

  .page-exit {
      opacity: 1;
      transform: translateX(0%);
  }

  .page-exit-active {
      opacity: 0.01;
      transform: translateX(100%);
      transition: all 300ms ease-out;
  }


3.Then, open MainComponent.js and add in the following to configure the animation:
  . . .

import { TransitionGroup, CSSTransition } from 'react-transition-group';

  . . .

          <TransitionGroup>
            <CSSTransition key={this.props.location.key} classNames="page" timeout={300}>
              <Switch location={this.props.location}>
                  <Route path='/home' component={HomePage} />
                  <Route exact path='/aboutus' component={() => <About leaders={this.props.leaders} />} />} />
                  <Route exact path='/menu' component={() => <Menu dishes={this.props.dishes} />} />
                  <Route path='/menu/:dishId' component={DishWithId} />
                  <Route exact path='/contactus' component={() => <Contact resetFeedbackForm={this.props.resetFeedbackForm} />} />
                  <Redirect to="/home" />
              </Switch>
            </CSSTransition>
          </TransitionGroup>

  . . .

  Save all the changes and do a Git commit with the message "React Animations".

Conclusions
In this exercise we implemented simple animation using react-transition-group.


Exercise (Instructions): React Animation Components:
Objectives and Outcomes
In this exercise you will learn to use react-animation-components to add more subtle animations to your React app.
At the end of this exercise you will be able to:

Use react-animation-components to add more subtle animations to your React app.

1. Install react-animation-components into your React app as follows:
  yarn add react-animation-components@3.0.0

  Since this also requires prop-types so add that too as follows:
  yarn add prop-types@15.6.0

2.Adding Animations
  Open HomeComponents.js and update it as follows:
  . . .

  import { FadeTransform } from 'react-animation-components';

  . . .

            <FadeTransform
                in
                transformProps={{
                    exitTransform: 'scale(0.5) translateY(-50%)'
                }}>
                <Card>
                    <CardImg src={baseUrl + item.image} alt={item.name} />
                    <CardBody>
                    <CardTitle>{item.name}</CardTitle>
                    {item.designation ? <CardSubtitle>{item.designation}</CardSubtitle> : null }
                    <CardText>{item.description}</CardText>
                    </CardBody>
                </Card>
            </FadeTransform>

  . . .

  Open DishdetailComponents.js and update it as follows:
  . . .

  import { FadeTransform, Fade, Stagger } from 'react-animation-components';

  . . .

            <FadeTransform
                in
                transformProps={{
                    exitTransform: 'scale(0.5) translateY(-50%)'
                }}>
            <Card>
                <CardImg top src={baseUrl + dish.image} alt={dish.name} />
                <CardBody>
                    <CardTitle>{dish.name}</CardTitle>
                    <CardText>{dish.description}</CardText>
                </CardBody>
            </Card>
            </FadeTransform>

  . . .

                    <Stagger in>
                        {comments.map((comment) => {
                            return (
                                <Fade in>
                                <li key={comment.id}>
                                <p>{comment.comment}</p>
                                <p>-- {comment.author} , {new Intl.DateTimeFormat('en-US', { year: 'numeric', month: 'short', day: '2-digit'}).format(new Date(Date.parse(comment.date)))}</p>
                                </li>
                                </Fade>
                            );
                        })}
                        </Stagger>

  . . .

  Save all the changes and do a Git commit with the message "React Animation Components".

Conclusions
In this exercise you saw yet another way of adding subtle animations using react-animation-components.

Assignment- Redux, Client-Server Communication and Fetch:
In this assignment, you will update the web application to get data from the server to render the information corresponding to the leadership team of the company.
In addition, you will handle the submission of the feedback form by posting the feedback to the server.

Assignment Overview

At the end of this assignment, you should have completed the following:

Introduced new action types and action creators to support the fetching of the leaders information from the server and update the Redux store.
Updated the Home and the About component to render the information about the leaders using the downloaded data from the server
Add simple animations to the About component where the leaders information is displayed.
Enabled the users to submit feedback through the feedback form by creating a new feedback service that accepts the form data and uses Restangular to record their feedback on the server.
Assignment Requirements

Task 1
In this task, you will update the Redux actions and the Home and About components to use the data from the server for rendering the leader information:

Add new action types in ActionTypes.js to support the fetching of the leaders information from the server
Add new action creators in ActionCreators.js to enable the fetching of the leaders information from the server and update the Redux store
Update the code in leaders.js to respond to the dispatched Redux actions and update the Redux store and appropriately handle the loading and errors.
Update the code in MainComponent.js to fetch and use the leaders information.
Update HomeComponent.js to render the leader information.
Update AboutComponent.js to render the leaders information. You should handle the loading and error condition appropriately.

Task 2
In this task, you will enable the saving of the feedback data submitted using the feedback form in the Contact component. You will save the feedback form data submitted by the user to the server:

Implement a new action creator named postFeedback() that takes a Feedback object as a parameter and submits the feedback to the server using Fetch. Recall that the feedback data is accessible at http://localhost:3001/feedback on the json-server.
Update MainComponent.js to make the new dispatch method postFeedback() available to ContactComponent.
Update the ContactComponent.js to submit the form data using the postFeedback() method by passing the feedback form data.

Task 3
In this task you will use simple animation using react-animation-components to enable a staggered rendering of the list of leaders in AboutComponent:
Use the expand animation that we have already used earlier to judiciously apply animation to the various stages of the form submission.

Building and Deployment:
Objectives and Outcomes:
In this lesson you will learn about Webpack and how react-scripts uses webpack to package your React application to create a distribution folder.
At the end of this exercise you will be able to:
1.Understand the Webpack way of packaging applications into bundles
2.Use react-scripts to build a distribution folder with your React application bundled using Webpack.

1.Building the Distribution Folder:
  To build the distribution folder containing your React application, type the following at the prompt:
  npm run build
  This should build a distribution folder named build containing all your application files.
2.Deploying your React Application:
  To deploy your React application you need a server. Fortunately we already have the json-server available on our computer.
  Copy the contents of the build folder to the public folder of your json-server
  Now your React application can be accessed at the link http://localhost:3001/.
  If you are setting up a server on the cloud or anywhere, all that you need to do is copy the contents of the build folder to the server side to deploy your React application.
  The exact procedure depends on the cloud service provider that you choose to use.
  Please consult their documentation to see the procedure to set up the server.

Conclusions
In this exercise you learnt to use the  react-scripts to build and deploy your React application.

In the previous course on Bootstrap 4, we had seen the use of NPM scripts, Grunt and Gulp for building the distribution folder for our website.
We had seen how these scripts can be used for doing concatenation, uglification and minification in order to build the distribution folder which can then be deployed to our website.
Webpack is another approach that helps us do exactly the same. Web
pack is what is called a module bundler. What exactly is Webpack and how does it help us to build the distribution folder?
We will examine a little more details about that in this lecture and also see how we can use it in the exercise that follows.
For our React Application, we had used Create React App to scaffold out our React Application.
Create React App itself, uses React scripts and NPM module underneath for supporting all the various activities that we need to do for our React Application.
It internally uses Webpack to do the building of the distribution folder.
So, in the exercise, we will examine how we can make use of it to build our distribution folder.
Before that, let's learn a little bit about Webpack.
Since our React Application is already set up with Webpack and all the configuration is automatically done for us, we don't need to worry about setting up the pack.
Webpack is a module bundler for modern JavaScript applications.
Now, what Webpack does is, it looks at the entire structure of your application.
So, it recursively traverses through your code looking to see how best to bundle the information into what is called as bundles.
Then that pack looks at your code,it treats every file that you have, be it a JavaScript file, be it a CSS file, be it a Sass file, be it an image file, whatever, it treats every one of them as modules from its perspective and then it decides, what is the best way of packaging this modules into what are called bundles that can be downloaded from the server to your web browser in a comfortable and convenient manner.
So, when we talk about Webpack, we obviously need to clarify what a bundle means.
As I briefly stated in the previous slide, a bundle is nothing but a JavaScript file that incorporates assets.
Now, you have to keep this in mind that Webpack treats everything as JavaScript.
To it, whether it is CSS or any of the other kinds of files, they will also be treated as JavaScript from the perspective of a pack.
Now, don't get too concerned. Webpack knows how to package them and treat them as JavaScript modules when it prepares those bundles.
So, a bundle is something that groups together modules that belong together.
So, it bundles those modules together that should be served to the client in a single response to a request.
So webpack itself makes a decision on saying, what part should be joined together into a bundle and should be delivered together so that the rendering of your web application is done in the most effective manner?
So, what Webpack does is, it starts at the top most level.
So, it's starts there and then it follows all the imports that you use in those down their path and build up a hierarchical organization of all the different parts.
So, what is called as a dependency graph is built by the pack.
Now, using this dependency graph, webpack then decides how to package its bundles and that emits one or more bundles as they make sense for your particular application that Webpack is bundling.
In the process of doing it, when it is handling non-JavaScript files, like CSS, HTML and Sass or images and so on, then it uses plugins that enable you to pre-process and minify those files, those non-JavaScript files into a way that they can be bundled into your Webpack bundles.
If you are using Webpack from the scratch, then you would describe some of the configuration for your Webpack to work on these files in a file named webpack.config.js which should be included in the root folder of your application.
Now, when we talk about Webpack, there are four concepts that are important for us to understand on how Webpack works on things.
The first one is entry. Entry is a point that which the Webpack should start and follow down to build the dependency graph.
Now, the second part is what we'll call the output. In Webpack, the output is the set of bundles that are Webpack prepares on your behalf.
The third one is loaders. Now, Webpack as I said only understands JavaScript and it knows only how to work with JavaScript.
But as I also mentioned, Webpack treats every file as a module.
So, those files that are not JavaScript, they have to be transformed and then put into your bundles by using appropriate transformations and then they will be added into your dependency graph.
This is where the use of the various plugins come in.
What do plugins help you to do? The plugins help you to perform the various actions and custom functionalities, like compilations that you need to do for building up your bundles.
So, it will help you to transform your CSS into a way that you can package into your JavaScript bundles and so on.
So, that is a quick introduction to how Webpack actually works.
Now, that we have briefly learnt about Webpack and Webpack concepts, let's move on to the exercise.
We will make use of React scripts which uses Webpack to generate the build folder for our React Application.



