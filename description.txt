Configuring your React Application:
1. Configure your React Project to use Reactstrap:
   Reactstrap is a package supporting easy to use React based Bootstrap 4 components.
   To configure your project to use reactstrap, type the following at the prompt to install reactstrap, and Bootstrap 4:
   yarn add bootstrap@4.0.0
   yarn add reactstrap@5.0.0
   yarn add react-popper@0.9.2

2. Configure to use Bootstrap 4:
   Next, open index.js file in the src folder and add the following line into the imports before the import of index.css(to apply custom css on bootstrap styles):
   import 'bootstrap/dist/css/bootstrap.min.css';

3. Adding a Navigation Bar:
   Open App.js in the src folder and update it as follows:
   import { Navbar, NavbarBrand } from 'reactstrap';

class App extends Component {
  render() {
    return (
      <div className="App">
        <Navbar dark color="primary">
          <div className="container">
            <NavbarBrand href="/">Ristorante Con Fusion</NavbarBrand>
          </div>
        </Navbar>
      </div>
    );
  }
}

Exercise (Instructions): React Components Part 1:
In this exercise we added a new component to our React application,
added data to its
and then updated the app to show the information in the web page.

Exercise React Components Part 2
n this exercise we added a new component to our React application,
added data to its class,
and then updated the app to show the information in the web page.

React Components Week 2:
In this exercise we learned how to structure the app into presentational and container components.
1. Enable your presentational components to be concerned with the look and feel of your app
2. Enable container components to deal with the state, provide the data and handle user interactions.

React life cycle methods:
1. getSnapshotBeforeUpdate => This may be needed in situations, for example, when you're scrolling, you have this scrollbar in a component
and you're scrolling and you want to remember the position of the scroll at the point
so that when the component re-renders then you will retain that scrolling position, then that would be useful for saving the information.

Exercise: Functional Components:
We reimplemented both the MenuComponent and DishdetailComponent as pure functional components.

Exercise: Header and Footer:
n this exercise we updated the React application to use Font Awesome and Bootstrap Social,
and also integrated two new components, Header and Footer, into our application.
First use yarn or npm to fetch Font Awesome and Bootstrap-social to the project by typing the following at the prompt:

yarn add font-awesome@4.7.0
yarn add bootstrap-social@5.1.1

Then, open index.js file and update it as follows to enable your application to use Font Awesome and Bootstrap Social:

import 'font-awesome/css/font-awesome.css';
import 'bootstrap-social/bootstrap-social.css';

Then add Header and Footer components.

Exercise React Router:
n this exercise we learned about installing, configuring and using the React Router for navigation within our React app:

Objectives and Outcomes:
In this exercise we learn to use the React Router to configure and set up navigation among various pages in a React application. At the end of this exercise you will be able to:

Install and configure your application to use React Router
Configure the routes for React router to enable you to navigate to various pages within your React application
1.Installing and Configuring React Router
  First install React Router into your project by typing the following at the prompt:
  yarn add react-router-dom@4.2.2
  Then, open App.js and update it as follows:
  import { BrowserRouter } from 'react-router-dom';

. . .

    <BrowserRouter>
      <div className="App">
        <Main />
      </div>
    </BrowserRouter>
. . .

Add a Home Component:

Create a new file named HomeComponent.js in the components folder and add the following to it:

import React from 'react';

function Home(props) {
    return(
      <div className="container">
        <h4>Home</h4>
      </div>
    );
}

export default Home;

Configuring the Router
Open MainComponent.js file and update it
Open HeaderComponent.js and update its contents
Then, open FooterComponent.js and update it
Open MenuComponent.js and remove the onClick() from the Card in the RenderMenuItem() function.
Save all the changes and do a Git commit with the message "React Router".

Exercise: Single Page Applications:
In this exercise we will:
1. Leverage the React router to enable the development of single page applications
2. Provide a way of navigating among various pages using the React router support.
3. Integrate the DishdetailComponent into our single page application. We will use a route parameter in the URL to pass in the details of the selected dish to the DishdetailComponent. At the end of this exercise we will be able to configure the routes in our React router configuration to enable the use of route parameters within the URL to pass information to a component.

Assignment 2 ReactRouter and Single Page Applications:

Objectives and Outcomes:
1. Integrated the AboutComponent given above into the single page application.
2. Added a new functional component named <RenderLeader> through the RenderLeader() function to AboutComponent.js that renders the details of a given leader using the reactstrap <Media> component.
3. Construct and render the list of leaders in the About Us page using the <RenderLeader> component implemented above.

Exercise Controlled Forms:
In this exercise we have learnt how to create a controlled form within our React application.

Exercise Controlled Form Validation:
In this exercise you have learnt about doing simple client site form validation for controlled forms in React.

Exercise: Uncontrolled Forms:
n this exercise we learnt to use an uncontrolled component approach to add a form to our React application.

1. Adding a Modal to Host the Form
2. Then, add a button to the Navbar to enable toggling the modal
3. Adding the Uncontrolled Form to the modal body
4. Then, add the handleLogin function to the class to handle the form submission
In order to retrieve form elements data from dom into our react appliation, we use ref attribute.Since we are using reactstrap and it also uses ref attribute for some other purpose, we will use innerRef to  help React differentiate it from reactstrap ref.

Description Forms Controlled vs Uncontrolled components:
Normally, form elements in HTML maintain their own state within DOM and update it based on user input.
A Controlled component makes the React component itself control the form that it renders.
That is, it way of setting up forms in your React Application whereby your form information is directly tied into the state of your React component that is hosting the form instead of DOM.
So, any changes that you make to your form imports will be immediately reflected into the state of your React component.
The ContactComponent in our app is a controlled component.
Uncontrolled forms:
Ideally whenever we implement forms within out react application, we should implement them inside controlled components.
But there are many situations where we may not wish to go through all the expensive set up that we did for the control forms in the control components.
And also there may be situations where we may wish to just let the form information be handled by the DOM itself
As we realize any HTML form elements state is already tracked by the DOM.
So maybe in simple setup, we would be happy with letting the DOM track the form state, and then retrieve that directly from the form.
So how do we retrieve this information?
Now every, DOM form element has a ref associated with it, from which we can easily use that to extract their HTML form data into our application.
We need to tie in a function there to enable us to retrieve that information into our application.
Now this approach of using uncontrolled forms is a lot more easier in situations when we are mixing our React application code with non-React code.
So maybe we have a project that is already setup with some non-React part, and then we're adding in React components or React elements to that project to set up some parts of the project.
In that case, setting up uncontrolled forms where it interacts with the rest of your non-React code is more easier.

Exercise (Instructions): Introduction to Redux
In this exercise we learned to install and configure Redux and use it in your React application.

1 First install Redux and React-Redux into our application.
  yarn add redux@3.7.2
  yarn add react-redux@5.0.7

2. Next, create a folder named redux in the src folder and then add a file named reducer.js
3. Then, add a file named configureStore.js in the redux folder
4. Next, open App.js and update it.
5. Finally, update MainComponent.js to connect it to Redux store and use it.

React Redux Forms:
The react-redux-form provides us with a lot of features that enable us to leverage redux for our form persistence and also form validation.
What exactly is React-Redux-Form?
It is a versatile, fast and intuitive library for creating complex and performant forms in React using Redux.
The React-Redux-Form itself persist the state of our form into a model in the redux store.
And React-Redux-Form also provides a collection of reducer creators and action creators for us that enables us to do all this work for us without writing much code.
Now that's where the React-Redux-Form takes care of all the grunt work behind persisting the form in the Redux store.
Why would you need that?
Say, for example, we are on a view and we're filling out a form and then we navigate out of the view.
Very often when we have standard react components, when we move out of a view, the state of the, whatever local state that you stored in that component will get destroyed.
And so when we return to the same view, if we had filled up a form, the form would remain unfilled.
Suppose we want to persist the state of the form even across page reloads or as we navigate in and out of a view,
then React-Redux-Form would be of use to us.
So, this is achieved by the form data being stored in the redux in a model.
And all the details of how this persistence is done is automatically taken care of by React-Redux-Form without us needing to do any reducer functions or the action creators on our behalf.
And also, React-Redux-Form brings in its own support for validation as we will see in one of the exercises that follows this lecture.
If we want to use React-Redux-Form purely for its form validation and not require the form data to be persistent in the redux store, instead if we want it to be persistent in the local state of the component, then we can simply use a local form that is also supported by React-Redux-Form to create forms.
This is suitable when we don't need persistence across component mounting/unmounting in our application. So, that's the advantage of using local forms.

Exercise (Instructions): React Redux Form
In this exercise we converted the controlled form that we created earlier into a form supported by react-redux-form.
1. We first install the react-redux-form into our project:
   yarn add react-redux-form@1.16.8
2. Then open ContactComponent.js and update the Feedback Form to use react-redux-form.

React Redux Form Validation
In this exercise we learned about implementing simple form validation in ContactComponent.js using react-redux-form.

React Forms and Redux Assignment:
In this assignment you will update the DishdetailComponent.js to include a form and do the form validation in code.
At the end of this assignment, you should have completed the following tasks to update the page:

1. Added a new class component named CommentForm to DishdetailComponent.js.
2. Provide a form to enable users to submit their comments
3. Validate the information entered by the users in the form

Assignment Requirements:

Task 1
In this task you will add a new class component named CommentForm. You need to complete the following:
Add a new class component named CommentForm that will add a button to the view as shown in the image below.
When the button is clicked, it toggles a modal that will display the comment form.
The CommentForm component is used by the RenderComments function to display the button for toggling the modal.

Task 2
In this task you will construct the form for users to submit their comments as shown in the image below. You need to complete the following:
Set up the form as a local form using the react-redux-form with the three fields: author, rating and comment.
The rating field in the comment form is implemented using a select, the author is implemented using a text field, while the comment uses a textarea with six rows.

Task 3
In this task, you will enable form validation as shown in the images below. You need to complete the following:
The author field should at least be three characters long.
The author field should be less than or equal to 15 characters.
The user should be alerted by showing the invalid message displayed at the bottom of the field.

Exercise (Instructions): Combining Reducers
In this exercise we have learnt to split the reducer into multiple reducers that manage partial state, and then combine them together.

Exercise (Instructions): Redux Actions:
In this exercise, we're going to create our first action,
where by the comment that you submit will be added into the list of comments for our application.
So, we will modify by introducing a new action for our application, which we'll take the comment and then add it into the comments field.
So, this requires us to change the state of our application.
So, we need an action that enables us to change the state of our application in the Redux store.
So, when we submit the comment, we'll see that the submission of the comment will trigger action to be sent to your redux store,
and then this action will result in the comment being added into the comments part of the state of our redux store,
and then when the changes, then that will result in the store emitting a change,
and that will result in our main component going and getting the updated state from the redux store,
and then the main component passes the new state to all the chilled components,
and then the RenderComments component realizes that the comments part has changed, so it will have to be rendered.
So, react takes care of re rendering that with new the comment added into the list there.

Objectives and Outcomes:
In this exercise we will learn to define various Redux actions and implement the action creators to dispatch the actions to the Redux store. At the end of this exercise you will be able to:
Define Redux actions and implement the action creators
Dispatch actions from the action creators to update the system state in the Redux store
1. Creating Actions:
  In the redux folder create a new file named ActionTypes.js
  Then, create a file named ActionCreators.js
2. Next, update comments.js to initiate action when the action is dispatched by the ActionCreator
3. Now update MainComponent.js to make the action available for use within the DishdetailComponent
4. Finally, update DishdetailComponent.js to initiate the action upon the user submitting the comment form.

Redux Thunk: Objectives and Outcomes:
Redux Thunk middleware allows you to write action creators that return a function instead of an action. In this lesson you will see the use of redux thunk to return a function.
At the end of this lesson we will be able to:

Use Redux Thunk middleware to return a function instead of an action
Use a logger middleware to print a log of actions initiated on the Redux store.

The Redux Middleware provides the capability to run a code after an action is dispatched, before it reaches the reducer.
Now once an action reaches the reducer, the reducer will act on the action and make changes to the state of the store.
So before that point, we can intercept action and effect some changes before the action reaches the reducer.
So this is a place which enables third party extensions to be injected into your Redux application.
So for example, if you want to log all the actions that have been dispatched,
that is a good point for you to first capture the action,
log what the action is and then let it move on to the reducer,
and then you can then log the state of the application after the action is effected.
Similarly, if we want to allow asynchronous API calls, so for example,
we dispatch an action but the action would initially require access to a server from where we fetch the data and then send the data into your Redux store.
Then that is also a good place to interject a middleware in order to intercept the action and then carry out basing API call and then let the action proceed forward into the store.
Middleware forms a pipeline that wraps around the dispatch,
then it can make any changes there and it can pass that action forward.
If it requires, it can restart the dispatch pipeline as it is required.
And not only that, at that point, you even get access to the store state.
If you want to look at the store state and then make any modifications before you let the action pass through.
So here are the few examples of things that you can do with the middleware that you interject into your Redux application.
So the middleware can be typically used for:
1. Inspecting the actions and the state.
2. Modify actions
3. Dispatch other actions and then wait for the results from those actions before you allow this particular action to take place.
4. Stop an action from reaching the reducers etc
The applyMiddleware() function of redux sets up amiddleware pipeline and returns a store enhancer that is passed to createStore().
What is a Thunk in programming?
Thunk is a subroutine that is used to inject an additional calculation into another subroutine.
So this is a way to delay a calculation until its result is needed
and also allows you to insert operations at the beginning or the end of another subroutine.
A Redux Thunk is a middleware that allows you to write an action creator that will return a function instead of an action object.
Then that function can be executed and within that function, you can design it in such a way that you can use it to :
1. delay the dispatch of an action until a certain condition is met
   eg if you want to do a synchronous API call to a server, you may use a thunk in order to generate a synchronous API call,
   and then when the server replies and you receive the reply, at that point you can let the action proceed forward and then make modifications to the store.
2. Dispatch only if certain condition is met.

The inner function that you define inside a thunk gets access to both the dispatch() as well as getState()from store.
What does this permit you to do? Because you have access to get state, you can examine the state and then see if this action fits and can be allowed with the current state. So that would allow you to even modify the action, and also you'll get access to dispatch.
So for example, you can stop the current action, do something else, come back and then dispatch the action into the reducers.
It also allows you to do complex synchronous logic.
1. Multiple dispatches
2. Conditionl dispatches
3. Simple async logic
So for example with one action, you can actually end up dispatching multiple dispatches and may cause multiple effects if that is what you intend to do.
You can even do conditional dispatch depending on the condition.
So for example, if you issue an synchronous API call to the server, and if the server returns the result successfully,
then you can dispatch one action to the reducer.
If the API call returns a failure, then you can dispatch a different action to the reducer to make changes to the state accordingly.

If you want a more powerful way of doing things like complex async logics, then we have access to another library called a Redux Saga.
A Redux Saga allows you to use ES6 generators to generate pausable functions.
And also, the saga allows ongoing background thread like operations or processing behavior if you so require.
So complex react applications that require that kind of behavior would definitely benefit by using a Redux Saga in the place of a Redux Thunk.

Exercise (Instructions): Redux Thunk:
Objectives:
Use Redux Thunk middleware to return a function instead of an action
Use a logger middleware to print a log of actions initiated on the Redux store.i.e log all the changes that we caused to the Redux store into our console.

1. Install Redux Thunk and Logger.
  yarn add redux-thunk@2.2.0
  yarn add redux-logger@3.0.6
2. Then open configureStore.js and update it to use the Thunk and Logger
3. Next, open ActionTypes.js and add new action types
4. Then open ActionCreators.js and add new actions:
5. Next, open dishes.js and add the code to respond to actions.
6. Add a new component named LoadingComponent.js to display a loading message:
7. Now we will update the remaining components to use the actions. First, open MainComponent.js and update it
8. Open DishdetailComponent.js and update it.
9. Open HomeComponent.js and update it
10.Finally, update MenuComponent.js

Exercise (Instructions): React-Redux-Form Revisited:
In this exercise we explored the interaction between react-redux-form and the Redux store.
We learned how to map the form into the store so that the state of the form will be persisted in the store.
1.Update the Feedback Form:
  Add a new file named forms.js in the redux folder
  Then, open configureStore.js and update it to add the form to the reducers
  Next, open MainComponent.js and update it
  Open CommentComponent.js and update it.
Description:
In the React-Redux-Form lesson in the previous module, we learned how to use the React-Redux-Form Package
and we saw how we can make use of the local form to create a React-Redux-Form in our application,
and then we saw that the state is mapped into the local state of the component.
Now, if we want to make use of the full power of the React-Redux-Form whereby the form state is persisted in the Redux store instead of in the components state,
then we need to update our form to make use of the regular form rather than the local form from the React-Redux-Form.
So in this exercise, we updated our application in the contactComponent to enable us to make use of the full power of React-Redux-Form.

Exercise (Instructions): Setting up a Server using json-server:

Objectives and Outcomes
The Node module, json-server, provides a very simple way to set up a web server that supports a full-fledged REST API server.
It can also serve up static web content from a folder.
This lesson we will leverage these two features to provide the back-end for our React application.
In this exercise, we will configure and start a server using json-server to enable serving our application data to our React application.
At the end of this exercise, we will be able to:

Configure and start a simple server using the json-server module
Configure our server to serve up static web content stored in a folder named public.

1.Installing json-server:
  json-server is a node module, and hence can be installed globally by typing the following at the command prompt:

  npm install json-server -g

2.Configuring the Server:
  At any convenient location on your computer, create a new folder named json-server, and move to this folder.
  Download the db.json file provided above to this folder.
  Move to this folder in your terminal window, and type the following at the command prompt to start the server:

  json-server --watch db.json -p 3001 -d 2000

  The reason for using this watch flag is that?
  This json-server will keep a watch on the db.jason file and anytime the db.jason file is modified.
  It'll reload the db.jason file and start serving up that modified data from the server.
  In addition, we can also give it -d flag, with a value, say for example, 2000.
  Which means that when the server receives a request, it will serve the data back to the requester after a two second delay.
  Now this would be used to simulate delay in accessing a server over the Internet.
  And another flag, -p 3001, though specify that the json-server should run at both number 3001.
  The default port number is 3000 for the json-server.
  But since our application is running at port number 3000, so we chose to run the json-server at port number 3001.
  This should start up a server at port number 3001 on your machine.

  The data from this server can be accessed by typing the following addresses into your browser address bar:
  http://localhost:3001/dishes
  http://localhost:3001/promotions
  http://localhost:3001/leaders
  http://localhost:3001/feedback

  Type these addresses into the browser address and see the JSON data being served up by the server.
  This data is obtained from the db.json file.
  The json-server also provides a static web server.
  Any resources that you put in a folder named public in the json-server folder above, will be served by the server at the following address:

  http://localhost:3001/

  Shut down the server by typing ctrl-C in the terminal window.

3.Serving up the Images:
  Create a public folder in your json-server folder.
  Download the images.zip file that we provide above, unzip it and move the images folder containing the images to the public folder.
  Restart the json-server as we did before.
  Now your server will serve up the images for our React app.
  You can view these images by typing the following into your browser address bar:

  http://localhost:3001/images/<image name>.png

Exercise (Instructions): Fetch from Server:

Objectives and Outcomes
In this exercise we will incorporate Fetch into our React app and then use it to communicate with the REST API server.
At the end of this exercise we will be able to:
1. Incorporate Fetch into your React app
2. Use Fetch to communicate with the REST API server

1. Fetch
  As a first step, let us install Fetch into our project:
  yarn add cross-fetch@2.1.0

  Now that we have installed Fetch, let us configure our application to connect to the server.
  First, create a file named baseUrl.js in the shared folder and add the following to it:
  export const baseUrl = 'http://localhost:3001/';
  This is really beneficial,let's say if my server is running at a different location, I would have a single place where I need to update the server address and don't need to go to change the rest of my application.

  Make sure that the json-server is running and serving up the data as illustrated in the previous exercise
  Next, open ActionTypes.js and update it as follows:

  export const ADD_COMMENTS = 'ADD_COMMENTS';
  export const COMMENTS_FAILED = 'COMMENTS_FAILED';
  export const PROMOS_LOADING = 'PROMOS_LOADING';
  export const ADD_PROMOS = 'ADD_PROMOS';
  export const PROMOS_FAILED = 'PROMOS_FAILED';

  Then, open ActionCreators.js and update it
  Similarly, open promotions.js and update it
  Now that the Redux actions are all updated, it's time to update the components.
  Open MainComponent.js and update it
  Then, open MenuComponent.js and update it
  Then, open HomeComponent.js and update it
  Then, open DishdetailComponent.js and update it

  All the images required for the dishes, the promotions and the leaders, will be now also fetched from the server site.
  So the only images that we will use from locally is the logo that obviously is not going to keep changing all the time.
  So that would be, the only local image that we will use from the assets folder in the public folder.Rest of the images will be loaded from server.

Exercise (Instructions): Fetch Post Comment:

Objectives and Outcomes:

In this exercise we will learn how to configure Fetch to be able to post data to the server.
At the end of this exercise we will be able to:
Configure Fetch to post data (comments) to the server
Receive and process the response to the POST operation on the server.
The modification of the data on the server site is in turn when Fetched by and then pushed into our Redux store, so that the update is reflected into our Redux store and thereafter, reflected into our view, when the Redux store gets updated.

1. Posting a Comment:
  Open ActionCreators.js and update it

  Open comment.js and remove 2 lines from it:
  comment.id = state.comments.length;
  comment.date = new Date().toISOString();

  Open MainComponent.js and update it.

  Finally, open DishdetailComponent.js and update it


